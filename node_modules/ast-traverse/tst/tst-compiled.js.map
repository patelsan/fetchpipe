{"version":3,"sources":["tst.js"],"names":[],"mappings":";;;;AAEA,IAAI,GAAG,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;;;AAGpC,IAAI,QAAQ,GAAG,OAAO,CAAC,iBAAiB,CAAC,CAAC;;;AAG1C,QAAQ,CAAC,GAAG,EAAE,EAAC,GAAG,EAAE,aAAS,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE;AAClD,eAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,MAAM,GAAG,eAAe,GAAG,MAAM,CAAC,IAAI,GAC3D,OAAO,GAAG,IAAI,IAAI,GAAG,KAAK,SAAS,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,CAAA,AAAC,GAAG,EAAE,CAAA,AAAC,CAAC,CAAC;KAC1E,EAAC,CAAC,CAAC;AACJ,OAAO,CAAC,GAAG,EAAE,CAAC;;;;;;;;;;;;;;;AAgBd,IAAI,MAAM,GAAG,CAAC,CAAC;AACf,QAAQ,CAAC,GAAG,EAAE;AACV,OAAG,EAAE,aAAS,IAAI,EAAE;AAChB,eAAO,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;AACrD,cAAM,IAAI,CAAC,CAAC;KACf;AACD,QAAI,EAAE,gBAAW;AACb,cAAM,IAAI,CAAC,CAAC;KACf;CACJ,CAAC,CAAC;AACH,OAAO,CAAC,GAAG,EAAE,CAAC;;;;;;;;;;;;;;;;;;AAoBd,QAAQ,CAAC,GAAG,EAAE;AACV,OAAG,EAAE,aAAS,IAAI,EAAE;AAChB,eAAO,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC1B;AACD,gBAAY,EAAE,sBAAS,IAAI,EAAE,IAAI,EAAE;AAC/B,eAAO,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,YAAY,CAAC;KACrD;CACJ,CAAC,CAAC","file":"tst-compiled.js","sourcesContent":["// ast is a Mozilla Parser API compatible structure\n// generated by Esprima or another parser\nvar ast = require(\"./tst-ast.json\");\n// or: var ast = require(\"esprima\").parse(\"f(1, x) + 2\");\n\nvar traverse = require(\"../ast-traverse\");\n\n// print AST node types, pre-order (node first, then its children)\ntraverse(ast, {pre: function(node, parent, prop, idx) {\n    console.log(node.type + (parent ? \" from parent \" + parent.type +\n        \" via \" + prop + (idx !== undefined ? \"[\" + idx + \"]\" : \"\") : \"\"));\n}});\nconsole.log();\n/*\n =>\n Program\n ExpressionStatement from parent Program via body[0]\n BinaryExpression from parent ExpressionStatement via expression\n CallExpression from parent BinaryExpression via left\n Identifier from parent CallExpression via callee\n Literal from parent CallExpression via arguments[0]\n Identifier from parent CallExpression via arguments[1]\n Literal from parent BinaryExpression via right\n */\n\n\n// you can also visit post-order, or both\n// all four arguments are provided to both visitors (left out unused below)\nvar indent = 0;\ntraverse(ast, {\n    pre: function(node) {\n        console.log(Array(indent + 1).join(\" \") + node.type);\n        indent += 4;\n    },\n    post: function() {\n        indent -= 4;\n    }\n});\nconsole.log();\n/*\n=>\n Program\n     ExpressionStatement\n         BinaryExpression\n             CallExpression\n                 Identifier\n                 Literal\n                 Identifier\n             Literal\n*/\n\n\n// return false from the pre-visitor to skip traversing its children\n// throw an exception to abort traversal\n\n\n// by default node property names beginning with $ are skipped\n// but you can supply your own skipProperty function instead\ntraverse(ast, {\n    pre: function(node) {\n        console.log(node.type);\n    },\n    skipProperty: function(prop, node) {\n        return prop === \"parent\" || prop === \"expression\";\n    }\n});\n/*\n=>\n Program\n ExpressionStatement\n*/\n"]}