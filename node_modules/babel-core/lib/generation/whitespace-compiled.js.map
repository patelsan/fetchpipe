{"version":3,"sources":["whitespace.js"],"names":[],"mappings":"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","file":"whitespace-compiled.js","sourcesContent":["/**\n * Returns `i`th number from `base`, continuing from 0 when `max` is reached.\n * Useful for shifting `for` loop by a fixed number but going over all items.\n *\n * @param {Number} i Current index in the loop\n * @param {Number} base Start index for which to return 0\n * @param {Number} max Array length\n * @returns {Number} shiftedIndex\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getLookupIndex(i, base, max) {\n  i += base;\n\n  if (i >= max) {\n    i -= max;\n  }\n\n  return i;\n}\n\n/**\n * Get whitespace around tokens.\n */\n\nvar Whitespace = (function () {\n  function Whitespace(tokens) {\n    _classCallCheck(this, Whitespace);\n\n    this.tokens = tokens;\n    this.used = {};\n\n    // Profiling this code shows that while generator passes over it, indexes\n    // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.\n\n    // We use this implementation detail for an optimization: instead of always\n    // starting to look from `this.tokens[0]`, we will start `for` loops from the\n    // previous successful match. We will enumerate all tokensâ€”but the common\n    // case will be much faster.\n\n    this._lastFoundIndex = 0;\n  }\n\n  /**\n   * Count all the newlines before a node.\n   */\n\n  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node starts with\n      if (node.start === token.start) {\n        startToken = tokens[i - 1];\n        endToken = token;\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    return this.getNewlinesBetween(startToken, endToken);\n  };\n\n  /**\n   * Count all the newlines after a node.\n   */\n\n  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node ends with\n      if (node.end === token.end) {\n        startToken = token;\n        endToken = tokens[i + 1];\n        if (endToken.type.label === \",\") endToken = tokens[i + 2];\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    if (endToken && endToken.type.label === \"eof\") {\n      return 1;\n    } else {\n      var lines = this.getNewlinesBetween(startToken, endToken);\n      if (node.type === \"CommentLine\" && !lines) {\n        // line comment\n        return 1;\n      } else {\n        return lines;\n      }\n    }\n  };\n\n  /**\n   * Count all the newlines between two tokens.\n   */\n\n  Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {\n    if (!endToken || !endToken.loc) return 0;\n\n    var start = startToken ? startToken.loc.end.line : 1;\n    var end = endToken.loc.start.line;\n    var lines = 0;\n\n    for (var line = start; line < end; line++) {\n      if (typeof this.used[line] === \"undefined\") {\n        this.used[line] = true;\n        lines++;\n      }\n    }\n\n    return lines;\n  };\n\n  return Whitespace;\n})();\n\nexports[\"default\"] = Whitespace;\nmodule.exports = exports[\"default\"];"]}