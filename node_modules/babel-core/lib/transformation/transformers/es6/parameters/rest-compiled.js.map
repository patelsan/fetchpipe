{"version":3,"sources":["rest.js"],"names":[],"mappings":"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","file":"rest-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _util = require(\"../../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar memberExpressionOptimisationVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope: function Scope(node, parent, scope, state) {\n    // check if this scope has a local binding that will shadow the rest parameter\n    if (!scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      this.skip();\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Flow: function Flow() {\n    // don't touch reference in type annotations\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, state) {\n    // skip over functions as whatever `arguments` we reference inside will refer\n    // to the wrong function\n    var oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    this.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    // we can't guarantee the purity of arguments\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    // is this a referenced identifier and is it referencing the rest parameter?\n    if (node.name !== state.name) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      if (this.parentPath.isMemberExpression({ computed: true, object: node })) {\n        // if we know that this member expression is referencing a number then we can safely\n        // optimise it\n        var prop = this.parentPath.get(\"property\");\n        if (prop.isBaseType(\"number\")) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      // optimise single spread args in calls\n      if (this.parentPath.isSpreadElement() && state.offset === 0) {\n        var call = this.parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      state.references.push(this);\n    }\n  },\n\n  /**\n   * Deopt on use of a binding identifier with the same name as our rest param.\n   *\n   * See https://github.com/babel/babel/issues/2091\n   */\n\n  BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {\n    if (node.name === state.name) {\n      state.deopted = true;\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction optimiseMemberExpression(parent, offset) {\n  if (offset === 0) return;\n\n  var newExpr;\n  var prop = parent.property;\n\n  if (t.isLiteral(prop)) {\n    prop.value += offset;\n    prop.raw = String(prop.value);\n  } else {\n    // // UnaryExpression, BinaryExpression\n    newExpr = t.binaryExpression(\"+\", prop, t.literal(offset));\n    parent.property = newExpr;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction hasRest(node) {\n  return t.isRestElement(node.params[node.params.length - 1]);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope) {\n    if (!hasRest(node)) return;\n\n    var restParam = node.params.pop();\n    var rest = restParam.argument;\n\n    var argsId = t.identifier(\"arguments\");\n\n    // otherwise `arguments` will be remapped in arrow functions\n    argsId._shadowedFunctionLiteral = this;\n\n    // support patterns\n    if (t.isPattern(rest)) {\n      var pattern = rest;\n      rest = scope.generateUidIdentifier(\"ref\");\n\n      var declar = t.variableDeclaration(\"let\", pattern.elements.map(function (elem, index) {\n        var accessExpr = t.memberExpression(rest, t.literal(index), true);\n        return t.variableDeclarator(elem, accessExpr);\n      }));\n      node.body.body.unshift(declar);\n    }\n\n    // check and optimise for extremely common cases\n    var state = {\n      references: [],\n      offset: node.params.length,\n\n      argumentsNode: argsId,\n      outerBinding: scope.getBindingIdentifier(rest.name),\n\n      // candidate member expressions we could optimise if there are no other references\n      candidates: [],\n\n      // local rest binding name\n      name: rest.name,\n\n      // whether any references to the rest parameter were made in a function\n      deopted: false\n    };\n\n    this.traverse(memberExpressionOptimisationVisitor, state);\n\n    if (!state.deopted && !state.references.length) {\n      // we only have shorthands and there are no other references\n      if (state.candidates.length) {\n        var _arr = state.candidates;\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var candidate = _arr[_i];\n          candidate.replaceWith(argsId);\n          if (candidate.parentPath.isMemberExpression()) {\n            optimiseMemberExpression(candidate.parent, state.offset);\n          }\n        }\n      }\n      return;\n    } else {\n      state.references = state.references.concat(state.candidates);\n    }\n\n    // deopt shadowed functions as transforms like regenerator may try touch the allocation loop\n    state.deopted = state.deopted || !!node.shadow;\n\n    //\n\n    var start = t.literal(node.params.length);\n    var key = scope.generateUidIdentifier(\"key\");\n    var len = scope.generateUidIdentifier(\"len\");\n\n    var arrKey = key;\n    var arrLen = len;\n    if (node.params.length) {\n      // this method has additional params, so we need to subtract\n      // the index of the current argument position from the\n      // position in the array that we want to populate\n      arrKey = t.binaryExpression(\"-\", key, start);\n\n      // we need to work out the size of the array that we're\n      // going to store all the rest parameters\n      //\n      // we need to add a check to avoid constructing the array\n      // with <0 if there are less arguments than params as it'll\n      // cause an error\n      arrLen = t.conditionalExpression(t.binaryExpression(\">\", len, start), t.binaryExpression(\"-\", len, start), t.literal(0));\n    }\n\n    var loop = util.template(\"rest\", {\n      ARRAY_TYPE: restParam.typeAnnotation,\n      ARGUMENTS: argsId,\n      ARRAY_KEY: arrKey,\n      ARRAY_LEN: arrLen,\n      START: start,\n      ARRAY: rest,\n      KEY: key,\n      LEN: len\n    });\n\n    if (state.deopted) {\n      loop._blockHoist = node.params.length + 1;\n      node.body.body.unshift(loop);\n    } else {\n      // perform allocation at the lowest common denominator of all references\n      loop._blockHoist = 1;\n\n      var target = this.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n\n      // don't perform the allocation inside a loop\n      var highestLoop;\n      target.findParent(function (path) {\n        if (path.isLoop()) {\n          highestLoop = path;\n        } else if (path.isFunction()) {\n          // stop crawling up for functions\n          return true;\n        }\n      });\n      if (highestLoop) target = highestLoop;\n\n      target.insertBefore(loop);\n    }\n  }\n};\nexports.visitor = visitor;"]}