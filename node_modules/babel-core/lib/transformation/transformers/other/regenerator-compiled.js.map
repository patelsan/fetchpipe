{"version":3,"sources":["regenerator.js"],"names":[],"mappings":"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","file":"regenerator-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _regenerator = require(\"regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n// It's important to use the exact same NodePath constructor that\n// Regenerator uses, rather than require(\"ast-types\").NodePath, because\n// the version of ast-types that Babel knows about might be different from\n// the version that Regenerator depends on. See for example #1958.\nvar NodePath = _regenerator2[\"default\"].types.NodePath;\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: {\n    exit: function exit(node) {\n      if (node.async || node.generator) {\n        // Although this code transforms only the subtree rooted at the given\n        // Function node, that node might contain other generator functions\n        // that will also be transformed. It might help performance to ignore\n        // nested functions, and rely on the traversal to visit them later,\n        // but that's a small optimization. Starting here instead of at the\n        // root of the AST is the key optimization, since huge async/generator\n        // functions are relatively rare.\n        _regenerator2[\"default\"].transform(convertNodePath(this));\n      }\n    }\n  }\n};\n\nexports.visitor = visitor;\n// Given a Babel NodePath, return an ast-types NodePath that includes full\n// ancestry information (up to and including the Program node). This is\n// complicated by having to include intermediate objects like blockStatement.body\n// arrays, in addition to Node objects.\nfunction convertNodePath(path) {\n  var programNode;\n  var keysAlongPath = [];\n\n  while (path) {\n    var pp = path.parentPath;\n    var parentNode = pp && pp.node;\n    if (parentNode) {\n      keysAlongPath.push(path.key);\n\n      if (parentNode !== path.container) {\n        var found = Object.keys(parentNode).some(function (listKey) {\n          if (parentNode[listKey] === path.container) {\n            keysAlongPath.push(listKey);\n            return true;\n          }\n        });\n\n        if (!found) {\n          throw new Error(\"Failed to find container object in parent node\");\n        }\n      }\n\n      if (t.isProgram(parentNode)) {\n        programNode = parentNode;\n        break;\n      }\n    }\n\n    path = pp;\n  }\n\n  if (!programNode) {\n    throw new Error(\"Failed to find root Program node\");\n  }\n\n  var nodePath = new NodePath(programNode);\n\n  while (keysAlongPath.length > 0) {\n    nodePath = nodePath.get(keysAlongPath.pop());\n  }\n\n  return nodePath;\n}"]}