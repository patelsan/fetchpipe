{"version":3,"sources":["ancestry.js"],"names":[],"mappings":"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","file":"ancestry-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.findParent = findParent;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.inType = inType;\nexports.inShadow = inShadow;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n/**\n * Call the provided `callback` with the `NodePath`s of all the parents.\n * When the `callback` returns a truthy value, we return that node path.\n */\n\nfunction findParent(callback) {\n  var path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nfunction getFunctionParent() {\n  return this.findParent(function (path) {\n    return path.isFunction() || path.isProgram();\n  });\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nfunction getStatementParent() {\n  var path = this;\n  do {\n    if (Array.isArray(path.container)) {\n      return path;\n    }\n  } while (path = path.parentPath);\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    var earliest;\n    var keys = t.VISITOR_KEYS[deepest.type];\n\n    var _arr = ancestries;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var ancestry = _arr[_i];\n      var path = ancestry[i + 1];\n\n      // first path\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      // handle containers\n      if (path.listKey && earliest.listKey === path.listKey) {\n        // we're in the same container so check if we're earlier\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      // handle keys\n      var earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      var currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        // key appears before so it's earlier\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  var minDepth = Infinity;\n\n  // last common ancestor\n  var lastCommonIndex, lastCommon;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  var ancestries = paths.map(function (path) {\n    var ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== _this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  var first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (var i = 0; i < minDepth; i++) {\n    var shouldMatch = first[i];\n\n    var _arr2 = ancestries;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var ancestry = _arr2[_i2];\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nfunction getAncestry() {\n  var path = this;\n  var paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inType() {\n  var path = this;\n  while (path) {\n    var _arr3 = arguments;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var type = _arr3[_i3];\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n\n  return false;\n}\n\n/**\n * Check if we're inside a shadowed function.\n */\n\nfunction inShadow(key) {\n  var path = this;\n  do {\n    if (path.isFunction()) {\n      var shadow = path.node.shadow;\n      if (shadow) {\n        // this is because sometimes we may have a `shadow` value of:\n        //\n        //   { this: false }\n        //\n        // we need to catch this case if `inShadow` has been passed a `key`\n        if (!key || shadow[key] !== false) {\n          return path;\n        }\n      } else if (path.isArrowFunctionExpression()) {\n        return path;\n      }\n\n      // normal function, we've found our function context\n      return null;\n    }\n  } while (path = path.parentPath);\n  return null;\n}"]}