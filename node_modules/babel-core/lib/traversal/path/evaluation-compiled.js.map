{"version":3,"sources":["evaluation.js"],"names":[],"mappings":"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","file":"evaluation-compiled.js","sourcesContent":["/* eslint eqeqeq: 0 */\n\n\"use strict\";\n\nexports.__esModule = true;\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nvar VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nfunction evaluateTruthy() {\n  var res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value }`. `confident` indicates\n * whether or not we had to drop out of evaluating the expression because of\n * hitting an unknown node that we couldn't confidently find the value of.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined }\n *\n */\n\nfunction evaluate() {\n  var confident = true;\n\n  var value = evaluate(this);\n  if (!confident) value = undefined;\n  return {\n    confident: confident,\n    value: value\n  };\n\n  function evaluate(path) {\n    if (!confident) return;\n\n    var node = path.node;\n\n    if (path.isSequenceExpression()) {\n      var exprs = path.get(\"expressions\");\n      return evaluate(exprs[exprs.length - 1]);\n    }\n\n    if (path.isLiteral()) {\n      if (node.regex) {\n        // we have a regex and we can't represent it natively\n      } else {\n          return node.value;\n        }\n    }\n\n    if (path.isConditionalExpression()) {\n      if (evaluate(path.get(\"test\"))) {\n        return evaluate(path.get(\"consequent\"));\n      } else {\n        return evaluate(path.get(\"alternate\"));\n      }\n    }\n\n    if (path.isTypeCastExpression()) {\n      return evaluate(path.get(\"expression\"));\n    }\n\n    if (path.isIdentifier() && !path.scope.hasBinding(node.name, true)) {\n      if (node.name === \"undefined\") {\n        return undefined;\n      } else if (node.name === \"Infinity\") {\n        return Infinity;\n      } else if (node.name === \"NaN\") {\n        return NaN;\n      }\n    }\n\n    // \"foo\".length\n    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {\n      var _property = path.get(\"property\");\n      var object = path.get(\"object\");\n\n      if (object.isLiteral() && _property.isIdentifier()) {\n        var _value = object.node.value;\n        var type = typeof _value;\n        if (type === \"number\" || type === \"string\") {\n          return _value[_property.node.name];\n        }\n      }\n    }\n\n    if (path.isReferencedIdentifier()) {\n      var binding = path.scope.getBinding(node.name);\n      if (binding && binding.hasValue) {\n        return binding.value;\n      } else {\n        var resolved = path.resolve();\n        if (resolved === path) {\n          return confident = false;\n        } else {\n          return evaluate(resolved);\n        }\n      }\n    }\n\n    if (path.isUnaryExpression({ prefix: true })) {\n      var argument = path.get(\"argument\");\n      var arg = evaluate(argument);\n      switch (node.operator) {\n        case \"void\":\n          return undefined;\n        case \"!\":\n          return !arg;\n        case \"+\":\n          return +arg;\n        case \"-\":\n          return -arg;\n        case \"~\":\n          return ~arg;\n        case \"typeof\":\n          if (argument.isFunction()) {\n            return \"function\";\n          } else {\n            return typeof arg;\n          }\n      }\n    }\n\n    if (path.isArrayExpression() || path.isObjectExpression()) {\n      // we could evaluate these but it's probably impractical and not very useful\n    }\n\n    if (path.isLogicalExpression()) {\n      // If we are confident that one side of an && is false, or one side of\n      // an || is true, we can be confident about the entire expression\n      var wasConfident = confident;\n      var left = evaluate(path.get(\"left\"));\n      var leftConfident = confident;\n      confident = wasConfident;\n      var right = evaluate(path.get(\"right\"));\n      var rightConfident = confident;\n      var uncertain = leftConfident !== rightConfident;\n      confident = leftConfident && rightConfident;\n\n      switch (node.operator) {\n        case \"||\":\n          if ((left || right) && uncertain) {\n            confident = true;\n          }\n          return left || right;\n        case \"&&\":\n          if (!left && leftConfident || !right && rightConfident) {\n            confident = true;\n          }\n          return left && right;\n      }\n    }\n\n    if (path.isBinaryExpression()) {\n      var left = evaluate(path.get(\"left\"));\n      var right = evaluate(path.get(\"right\"));\n\n      switch (node.operator) {\n        case \"-\":\n          return left - right;\n        case \"+\":\n          return left + right;\n        case \"/\":\n          return left / right;\n        case \"*\":\n          return left * right;\n        case \"%\":\n          return left % right;\n        case \"**\":\n          return Math.pow(left, right);\n        case \"<\":\n          return left < right;\n        case \">\":\n          return left > right;\n        case \"<=\":\n          return left <= right;\n        case \">=\":\n          return left >= right;\n        case \"==\":\n          return left == right;\n        case \"!=\":\n          return left != right;\n        case \"===\":\n          return left === right;\n        case \"!==\":\n          return left !== right;\n        case \"|\":\n          return left | right;\n        case \"&\":\n          return left & right;\n        case \"^\":\n          return left ^ right;\n        case \"<<\":\n          return left << right;\n        case \">>\":\n          return left >> right;\n        case \">>>\":\n          return left >>> right;\n      }\n    }\n\n    if (path.isCallExpression()) {\n      var callee = path.get(\"callee\");\n      var context;\n      var func;\n\n      // Number(1);\n      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n        func = global[node.callee.name];\n      }\n\n      if (callee.isMemberExpression()) {\n        var object = callee.get(\"object\");\n        var property = callee.get(\"property\");\n\n        // Math.min(1, 2)\n        if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0) {\n          context = global[object.node.name];\n          func = context[property.node.name];\n        }\n\n        // \"abc\".charCodeAt(4)\n        if (object.isLiteral() && property.isIdentifier()) {\n          var type = typeof object.node.value;\n          if (type === \"string\" || type === \"number\") {\n            context = object.node.value;\n            func = context[property.node.name];\n          }\n        }\n      }\n\n      if (func) {\n        var args = path.get(\"arguments\").map(evaluate);\n        if (!confident) return;\n\n        return func.apply(context, args);\n      }\n    }\n\n    confident = false;\n  }\n}"]}