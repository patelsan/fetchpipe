{"version":3,"sources":["inferer-reference.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;AAEb,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC;;;AAG1B,SAAS,uBAAuB,CAAC,GAAG,EAAE;AAAE,MAAI,GAAG,IAAI,GAAG,CAAC,UAAU,EAAE;AAAE,WAAO,GAAG,CAAC;GAAE,MAAM;AAAE,QAAI,MAAM,GAAG,EAAE,CAAC,AAAC,IAAI,GAAG,IAAI,IAAI,EAAE;AAAE,WAAK,IAAI,GAAG,IAAI,GAAG,EAAE;AAAE,YAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;OAAE;KAAE,AAAC,MAAM,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC,AAAC,OAAO,MAAM,CAAC;GAAE;CAAE;;AAEhR,IAAI,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;;AAEvC,IAAI,CAAC,GAAG,uBAAuB,CAAC,MAAM,CAAC,CAAC;;;;;;AAMxC,OAAO,CAAC,SAAS,CAAC,GAAG,UAAU,IAAI,EAAE;AACnC,MAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,OAAO;;;;AAIjC,MAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AAC/C,MAAI,OAAO,EAAE;AACX,QAAI,OAAO,CAAC,UAAU,CAAC,cAAc,EAAE;AACrC,aAAO,OAAO,CAAC,UAAU,CAAC,cAAc,CAAC;KAC1C,MAAM;AACL,aAAO,0CAA0C,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;KACpE;GACF;;;AAGD,MAAI,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;AAC7B,WAAO,CAAC,CAAC,kBAAkB,EAAE,CAAC;GAC/B,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;AAC1D,WAAO,CAAC,CAAC,oBAAoB,EAAE,CAAC;GACjC,MAAM,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;;GAErC;CACF,CAAC;;;;;;AAMF,SAAS,0CAA0C,CAAC,IAAI,EAAE,IAAI,EAAE;AAC9D,MAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;;AAE1C,MAAI,KAAK,GAAG,EAAE,CAAC;AACf,MAAI,CAAC,cAAc,GAAG,CAAC,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;;AAEnD,MAAI,0BAA0B,GAAG,EAAE,CAAC;AACpC,MAAI,kBAAkB,GAAG,2BAA2B,CAAC,OAAO,EAAE,IAAI,EAAE,0BAA0B,CAAC,CAAC;;AAEhG,MAAI,QAAQ,GAAG,wBAAwB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACpD,MAAI,QAAQ,EAAE;AACZ,QAAI,sBAAsB,GAAG,2BAA2B,CAAC,OAAO,EAAE,QAAQ,CAAC,WAAW,CAAC,CAAC;;;AAGxF,sBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,UAAU,IAAI,EAAE;AAC7D,aAAO,sBAAsB,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KACjD,CAAC,CAAC;;;AAGH,SAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;GACrC;;AAED,MAAI,kBAAkB,CAAC,MAAM,EAAE;;;AAG7B,QAAI,qBAAqB,GAAG,kBAAkB,CAAC,OAAO,EAAE,CAAC;AACzD,QAAI,aAAa,GAAG,EAAE,CAAC;AACvB,sBAAkB,GAAG,EAAE,CAAC;AACxB,QAAI,IAAI,GAAG,qBAAqB,CAAC;AACjC,SAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE;AACvC,UAAI,SAAS,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC;AACzB,UAAI,cAAc,GAAG,SAAS,CAAC,KAAK,CAAC;AACrC,UAAI,aAAa,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,SAAS;;AAEzD,mBAAa,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AACnC,wBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;;AAEnC,UAAI,cAAc,KAAK,IAAI,CAAC,KAAK,EAAE;AACjC,0BAAkB,GAAG,CAAC,SAAS,CAAC,CAAC;AACjC,cAAM;OACP;KACF;;;AAGD,sBAAkB,GAAG,kBAAkB,CAAC,MAAM,CAAC,0BAA0B,CAAC,CAAC;;;AAG3E,QAAI,KAAK,GAAG,kBAAkB,CAAC;AAC/B,SAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;AAC3C,UAAI,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;AAC3B,WAAK,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,CAAC,CAAC;KAC3C;GACF;;AAED,MAAI,KAAK,CAAC,MAAM,EAAE;AAChB,WAAO,CAAC,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC;GAC3C;CACF;;;;;;AAMD,SAAS,2BAA2B,CAAC,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE;AAC7D,MAAI,UAAU,GAAG,OAAO,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;AACpD,YAAU,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AACjC,SAAO,UAAU,CAAC,MAAM,CAAC,UAAU,SAAS,EAAE;AAC5C,aAAS,GAAG,SAAS,CAAC,OAAO,EAAE,CAAC;AAChC,QAAI,MAAM,GAAG,SAAS,CAAC,+BAA+B,CAAC,IAAI,CAAC,CAAC;AAC7D,QAAI,SAAS,IAAI,MAAM,KAAK,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAClE,WAAO,MAAM,KAAK,QAAQ,CAAC;GAC5B,CAAC,CAAC;CACJ;;;;;;AAMD,SAAS,mCAAmC,CAAC,IAAI,EAAE,IAAI,EAAE;AACvD,MAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;;AAElC,MAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC;AACxC,MAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC;;AAEtC,MAAI,MAAM,CAAC;AACX,MAAI,IAAI,CAAC,YAAY,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE;AACrC,UAAM,GAAG,KAAK,CAAC;GAChB,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE;AAC7C,UAAM,GAAG,IAAI,CAAC;GACf;AACD,MAAI,MAAM,EAAE;AACV,QAAI,QAAQ,KAAK,KAAK,EAAE;AACtB,aAAO,MAAM,CAAC,iBAAiB,EAAE,CAAC;KACnC,MAAM,IAAI,CAAC,CAAC,+BAA+B,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACnE,aAAO,CAAC,CAAC,oBAAoB,EAAE,CAAC;KACjC,MAAM;AACL,aAAO;KACR;GACF,MAAM;AACL,QAAI,QAAQ,KAAK,KAAK,EAAE,OAAO;GAChC;;;AAGD,MAAI,UAAU,CAAC;AACf,MAAI,QAAQ,CAAC;AACb,MAAI,IAAI,CAAC,iBAAiB,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAE;AAClD,cAAU,GAAG,IAAI,CAAC;AAClB,YAAQ,GAAG,KAAK,CAAC;GAClB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAE;AAC1D,cAAU,GAAG,KAAK,CAAC;AACnB,YAAQ,GAAG,IAAI,CAAC;GACjB;AACD,MAAI,CAAC,QAAQ,IAAI,CAAC,UAAU,EAAE,OAAO;;;AAGrC,UAAQ,GAAG,QAAQ,CAAC,OAAO,EAAE,CAAC;AAC9B,MAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,EAAE,OAAO;;;AAGlC,MAAI,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;AACpC,MAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,OAAO;;;AAG1C,MAAI,CAAC,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,YAAY,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO;;;AAGrE,SAAO,CAAC,CAAC,iCAAiC,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;CACjE;;;;;;AAMD,SAAS,wBAAwB,CAAC,IAAI,EAAE;AACtC,MAAI,UAAU,CAAC;AACf,SAAO,UAAU,GAAG,IAAI,CAAC,UAAU,EAAE;AACnC,QAAI,UAAU,CAAC,aAAa,EAAE,IAAI,UAAU,CAAC,uBAAuB,EAAE,EAAE;AACtE,UAAI,IAAI,CAAC,GAAG,KAAK,MAAM,EAAE;AACvB,eAAO;OACR,MAAM;AACL,eAAO,UAAU,CAAC;OACnB;KACF,MAAM;AACL,UAAI,GAAG,UAAU,CAAC;KACnB;GACF;CACF;;;;;;AAMD,SAAS,wBAAwB;;;4BAAa;QAAZ,IAAI;QAAE,IAAI;AACtC,eAAW,GAGX,IAAI,GACJ,KAAK,GACL,KAAK,GAGH,KAAK,GAQH,IAAI;;;AAhBZ,QAAI,WAAW,GAAG,wBAAwB,CAAC,IAAI,CAAC,CAAC;AACjD,QAAI,CAAC,WAAW,EAAE,OAAO;;AAEzB,QAAI,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACnC,QAAI,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;AACnB,QAAI,KAAK,GAAG,EAAE,CAAC;;AAEf,OAAG;AACD,UAAI,KAAK,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC,OAAO,EAAE,CAAC;;AAEpC,UAAI,KAAK,CAAC,mBAAmB,EAAE,EAAE;AAC/B,aAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;AAC9B,aAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;OAChC;;AAED,UAAI,KAAK,CAAC,kBAAkB,EAAE,EAAE;AAC9B,YAAI,IAAI,GAAG,mCAAmC,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AAC5D,YAAI,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;OAC5B;KACF,QAAQ,KAAK,CAAC,MAAM,EAAE;;AAEvB,QAAI,KAAK,CAAC,MAAM,EAAE;AAChB,aAAO;AACL,sBAAc,EAAE,CAAC,CAAC,yBAAyB,CAAC,KAAK,CAAC;AAClD,mBAAW,EAAE,WAAW;OACzB,CAAC;KACH,MAAM;WAC2B,WAAW;YAAE,IAAI;;;KAClD;GACF;CAAA;AACD,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC","file":"inferer-reference-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    var rawConstantViolations = constantViolations.reverse();\n    var visitedScopes = [];\n    constantViolations = [];\n    var _arr = rawConstantViolations;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var violation = _arr[_i];\n      var violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }\n\n    // add back on function constant violations since we can't track calls\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    // push on inferred types of violated paths\n    var _arr2 = constantViolations;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var violation = _arr2[_i2];\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  //\n  var typeofPath;\n  var typePath;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  // turn type value into a type annotation\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getParentConditionalPath(path) {\n  var parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}