{"version":3,"sources":["introspection.js"],"names":[],"mappings":"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","file":"introspection-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports.resolve = resolve;\nexports._resolve = _resolve;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nfunction matchesPattern(pattern, allowPartial) {\n  // not a member expression\n  if (!this.isMemberExpression()) return false;\n\n  var parts = pattern.split(\".\");\n  var search = [this.node];\n  var i = 0;\n\n  function matches(name) {\n    var part = parts[i];\n    return part === \"*\" || name === part;\n  }\n\n  while (search.length) {\n    var node = search.shift();\n\n    if (allowPartial && i === parts.length) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      // this part doesn't match\n      if (!matches(node.name)) return false;\n    } else if (t.isLiteral(node)) {\n      // this part doesn't match\n      if (!matches(node.value)) return false;\n    } else if (t.isMemberExpression(node)) {\n      if (node.computed && !t.isLiteral(node.property)) {\n        // we can't deal with this\n        return false;\n      } else {\n        search.unshift(node.property);\n        search.unshift(node.object);\n        continue;\n      }\n    } else if (t.isThisExpression(node)) {\n      if (!matches(\"this\")) return false;\n    } else {\n      // we can't deal with this\n      return false;\n    }\n\n    // too many parts\n    if (++i > parts.length) {\n      return false;\n    }\n  }\n\n  return i === parts.length;\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nfunction has(key) {\n  var val = this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Alias of `has`.\n */\n\nvar is = has;\n\nexports.is = is;\n/**\n * Opposite of `has`.\n */\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\n/**\n * This checks whether or now we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nfunction isCompletionRecord(allowInsideFunction) {\n  var path = this;\n  var first = true;\n\n  do {\n    var container = path.container;\n\n    // we're in a function so can't be a completion record\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return _lodashCollectionIncludes2[\"default\"](t.STATEMENT_OR_BLOCK_KEYS, this.key);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n\n  var binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  var path = binding.path;\n  var parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nfunction getSource() {\n  var node = this.node;\n  if (node.end) {\n    return this.hub.file.code.slice(node.start, node.end);\n  } else {\n    return \"\";\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execuete\n * before or after the input `target` element.\n */\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  // check if the two paths are in different functions, we can't track execution of these\n  var targetFuncParent = target.scope.getFunctionParent();\n  var selfFuncParent = this.scope.getFunctionParent();\n  if (targetFuncParent !== selfFuncParent) {\n    return \"function\";\n  }\n\n  var targetPaths = target.getAncestry();\n  //if (targetPaths.indexOf(this) >= 0) return \"after\";\n\n  var selfPaths = this.getAncestry();\n\n  // get ancestor where the branches intersect\n  var commonPath;\n  var targetIndex;\n  var selfIndex;\n  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {\n    var selfPath = selfPaths[selfIndex];\n    targetIndex = targetPaths.indexOf(selfPath);\n    if (targetIndex >= 0) {\n      commonPath = selfPath;\n      break;\n    }\n  }\n  if (!commonPath) {\n    return \"before\";\n  }\n\n  // get the relationship paths that associate these nodes to their common ancestor\n  var targetRelationship = targetPaths[targetIndex - 1];\n  var selfRelationship = selfPaths[selfIndex - 1];\n  if (!targetRelationship || !selfRelationship) {\n    return \"before\";\n  }\n\n  // container list so let's see which one is after the other\n  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {\n    return targetRelationship.key > selfRelationship.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);\n  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);\n  return targetKeyPosition > selfKeyPosition ? \"before\" : \"after\";\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resolve(dangerous, resolved) {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n      var binding = this.scope.getBinding(this.node.name);\n      if (!binding) return;\n\n      // reassigned so we can't really resolve it\n      if (!binding.constant) return;\n\n      // todo - lookup module in dependency graph\n      if (binding.kind === \"module\") return;\n\n      if (binding.path !== this) {\n        return binding.path.resolve(dangerous, resolved);\n      }\n    } else if (this.isTypeCastExpression()) {\n      return this.get(\"expression\").resolve(dangerous, resolved);\n    } else if (dangerous && this.isMemberExpression()) {\n      // this is dangerous, as non-direct target assignments will mutate it's state\n      // making this resolution inaccurate\n\n      var targetKey = this.toComputedKey();\n      if (!t.isLiteral(targetKey)) return;\n\n      var targetName = targetKey.value;\n\n      var target = this.get(\"object\").resolve(dangerous, resolved);\n\n      if (target.isObjectExpression()) {\n        var props = target.get(\"properties\");\n        var _arr = props;\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var prop = _arr[_i];\n          if (!prop.isProperty()) continue;\n\n          var key = prop.get(\"key\");\n\n          // { foo: obj }\n          var match = prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n          // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n          match = match || key.isLiteral({ value: targetName });\n\n          if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n        }\n      } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n        var elems = target.get(\"elements\");\n        var elem = elems[targetName];\n        if (elem) return elem.resolve(dangerous, resolved);\n      }\n    }\n}"]}