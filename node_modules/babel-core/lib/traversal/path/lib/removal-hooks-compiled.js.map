{"version":3,"sources":["removal-hooks.js"],"names":[],"mappings":"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","file":"removal-hooks-compiled.js","sourcesContent":["// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\n\"use strict\";\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\nvar pre = [\n\n/**\n * [Please add a description.]\n */\n\nfunction (self) {\n  if (self.key === \"body\" && (self.isBlockStatement() || self.isClassBody())) {\n    // function () NODE\n    // class NODE\n    // attempting to remove a block statement that's someones body so let's just clear all the inner\n    // statements instead\n    self.node.body = [];\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  var replace = false;\n\n  // () => NODE;\n  // removing the body of an arrow function\n  replace = replace || self.key === \"body\" && parent.isArrowFunctionExpression();\n\n  // throw NODE;\n  // removing a throw statement argument\n  replace = replace || self.key === \"argument\" && parent.isThrowStatement();\n\n  if (replace) {\n    self.replaceWith(t.identifier(\"undefined\"));\n    return true;\n  }\n}];\n\nexports.pre = pre;\n/**\n * Post hooks should be used for cleaning up parents\n */\n\nvar post = [\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  var removeParent = false;\n\n  // while (NODE);\n  // removing the test of a while/switch, we can either just remove it entirely *or* turn the `test` into `true`\n  // unlikely that the latter will ever be what's wanted so we just remove the loop to avoid infinite recursion\n  removeParent = removeParent || self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase());\n\n  // export NODE;\n  // just remove a declaration for an export as this is no longer valid\n  removeParent = removeParent || self.key === \"declaration\" && parent.isExportDeclaration();\n\n  // label: NODE\n  // stray labeled statement with no body\n  removeParent = removeParent || self.key === \"body\" && parent.isLabeledStatement();\n\n  // var NODE;\n  // remove an entire declaration if there are no declarators left\n  removeParent = removeParent || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 0;\n\n  // NODE;\n  // remove the entire expression statement if there's no expression\n  removeParent = removeParent || self.key === \"expression\" && parent.isExpressionStatement();\n\n  // if (NODE);\n  // remove the entire if since the consequent is never going to be hit, if there's an alternate then it's already been\n  // handled with the `pre` hook\n  removeParent = removeParent || self.key === \"test\" && parent.isIfStatement();\n\n  if (removeParent) {\n    parent.dangerouslyRemove();\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    // (node, NODE);\n    // we've just removed the second element of a sequence expression so let's turn that sequence\n    // expression into a regular expression\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  if (parent.isBinary()) {\n    // left + NODE;\n    // NODE + right;\n    // we're in a binary expression, better remove it and replace it with the last expression\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      // key === \"right\"\n      parent.replaceWith(parent.node.left);\n    }\n    return true;\n  }\n}];\nexports.post = post;"]}