{"version":3,"sources":["flow.js"],"names":[],"mappings":"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","file":"flow-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.createUnionTypeAnnotation = createUnionTypeAnnotation;\nexports.removeTypeDuplicates = removeTypeDuplicates;\nexports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containg them.\n */\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return t.unionTypeAnnotation(flattened);\n  }\n}\n\n/**\n * Dedupe type annotations.\n */\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n\n  // store union type groups to circular references\n  var typeGroups = [];\n\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (t.isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    //\n    if (t.isFlowBaseAnnotation(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    //\n    if (t.isUnionTypeAnnotation(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (t.isGenericTypeAnnotation(node)) {\n      var _name = node.id.name;\n\n      if (generics[_name]) {\n        var existing = generics[_name];\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[_name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  // add back in generics\n  for (var _name2 in generics) {\n    types.push(generics[_name2]);\n  }\n\n  return types;\n}\n\n/**\n * Create a type anotation based on typeof expression.\n */\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return t.stringTypeAnnotation();\n  } else if (type === \"number\") {\n    return t.numberTypeAnnotation();\n  } else if (type === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (type === \"boolean\") {\n    return t.booleanTypeAnnotation();\n  } else if (type === \"function\") {\n    return t.genericTypeAnnotation(t.identifier(\"Function\"));\n  } else if (type === \"object\") {\n    return t.genericTypeAnnotation(t.identifier(\"Object\"));\n  } else if (type === \"symbol\") {\n    return t.genericTypeAnnotation(t.identifier(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}"]}