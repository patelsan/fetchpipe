{"version":3,"sources":["validators.js"],"names":[],"mappings":"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","file":"validators-compiled.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.isBinding = isBinding;\nexports.isReferenced = isReferenced;\nexports.isValidIdentifier = isValidIdentifier;\nexports.isLet = isLet;\nexports.isBlockScoped = isBlockScoped;\nexports.isVar = isVar;\nexports.isSpecifierDefault = isSpecifierDefault;\nexports.isScope = isScope;\nexports.isImmutable = isImmutable;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _retrievers = require(\"./retrievers\");\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Check if the input `node` is a binding identifier.\n */\n\nfunction isBinding(node, parent) {\n  var bindingKey = _retrievers.getBindingIdentifiers.keys[parent.type];\n  if (bindingKey) {\n    return parent[bindingKey] === node;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if the input `node` is a reference to a bound variable.\n */\n\nfunction isReferenced(node, parent) {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case \"MemberExpression\":\n    case \"JSXMemberExpression\":\n      if (parent.property === node && parent.computed) {\n        return true;\n      } else if (parent.object === node) {\n        return true;\n      } else {\n        return false;\n      }\n\n    // no: new.NODE\n    // no: NODE.target\n    case \"MetaProperty\":\n      return false;\n\n    // yes: { [NODE]: \"\" }\n    // yes: { NODE }\n    // no: { NODE: \"\" }\n    case \"Property\":\n      if (parent.key === node) {\n        return parent.computed;\n      }\n\n    // no: var NODE = init;\n    // yes: var id = NODE;\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case \"ArrowFunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      var _arr = parent.params;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var param = _arr[_i];\n        if (param === node) return false;\n      }\n\n      return parent.id !== node;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case \"ExportSpecifier\":\n      if (parent.source) {\n        return false;\n      } else {\n        return parent.local === node;\n      }\n\n    // no: <div NODE=\"foo\" />\n    case \"JSXAttribute\":\n      return parent.name !== node;\n\n    // no: class { NODE = value; }\n    // yes: class { key = NODE; }\n    case \"ClassProperty\":\n      return parent.value === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    // no: class NODE {}\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.id !== node;\n\n    // yes: class { [NODE](){} }\n    case \"MethodDefinition\":\n      return parent.key === node && parent.computed;\n\n    // no: NODE: for (;;) {}\n    case \"LabeledStatement\":\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case \"CatchClause\":\n      return parent.param !== node;\n\n    // no: function foo(...NODE) {}\n    case \"RestElement\":\n      return false;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Check if the input `name` is a valid identifier name\n * and isn't a reserved word.\n */\n\nfunction isValidIdentifier(name) {\n  if (typeof name !== \"string\" || _esutils2[\"default\"].keyword.isReservedWordES6(name, true)) {\n    return false;\n  } else {\n    return _esutils2[\"default\"].keyword.isIdentifierNameES6(name);\n  }\n}\n\n/**\n * Check if the input `node` is a `let` variable declaration.\n */\n\nfunction isLet(node) {\n  return t.isVariableDeclaration(node) && (node.kind !== \"var\" || node._let);\n}\n\n/**\n * Check if the input `node` is block scoped.\n */\n\nfunction isBlockScoped(node) {\n  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);\n}\n\n/**\n * Check if the input `node` is a variable declaration.\n */\n\nfunction isVar(node) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !node._let;\n}\n\n/**\n * Check if the input `specifier` is a `default` import or export.\n */\n\nfunction isSpecifierDefault(specifier) {\n  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: \"default\" });\n}\n\n/**\n * Check if the input `node` is a scope.\n */\n\nfunction isScope(node, parent) {\n  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {\n    return false;\n  }\n\n  return t.isScopable(node);\n}\n\n/**\n * Check if the input `node` is definitely immutable.\n */\n\nfunction isImmutable(node) {\n  if (t.isType(node.type, \"Immutable\")) return true;\n\n  if (t.isLiteral(node)) {\n    if (node.regex) {\n      // regexs are mutable\n      return false;\n    } else {\n      // immutable!\n      return true;\n    }\n  } else if (t.isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      // immutable!\n      return true;\n    } else {\n      // no idea...\n      return false;\n    }\n  }\n\n  return false;\n}"]}