{"version":3,"sources":["json.js"],"names":[],"mappings":"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","file":"json-compiled.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar firstcharRegExp = /^[\\x20\\x09\\x0a\\x0d]*(.)/\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json(options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw new SyntaxError('Unexpected token ' + first)\n      }\n    }\n\n    debug('parse json')\n    return JSON.parse(body, reviver)\n  }\n\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      return debug('body already parsed'), next()\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      return debug('skip empty body'), next()\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      return debug('skip parsing'), next()\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @api public\n */\n\n\nfunction firstchar(str) {\n  var match = firstcharRegExp.exec(str)\n  return match ? match[1] : ''\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return contentType.parse(req).parameters.charset.toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}