{"version":3,"sources":["raw.js"],"names":[],"mappings":";;;;;;AAMA,YAAY,CAAA;;;;;;AAMZ,IAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAA;AAC5B,IAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,iBAAiB,CAAC,CAAA;AAC/C,IAAI,IAAI,GAAG,OAAO,CAAC,SAAS,CAAC,CAAA;AAC7B,IAAI,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAA;;;;;;AAM/B,MAAM,CAAC,OAAO,GAAG,GAAG,CAAA;;;;;;;;;;AAUpB,SAAS,GAAG,CAAC,OAAO,EAAE;AACpB,MAAI,IAAI,GAAG,OAAO,IAAI,EAAE,CAAC;;AAEzB,MAAI,OAAO,GAAG,IAAI,CAAC,OAAO,KAAK,KAAK,CAAA;AACpC,MAAI,KAAK,GAAG,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,GACtC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC,GAClC,IAAI,CAAC,KAAK,CAAA;AACd,MAAI,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,0BAA0B,CAAA;AAClD,MAAI,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,KAAK,CAAA;;AAEjC,MAAI,MAAM,KAAK,KAAK,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AACpD,UAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAA;GACtD;;;AAGD,MAAI,WAAW,GAAG,OAAO,IAAI,KAAK,UAAU,GACxC,WAAW,CAAC,IAAI,CAAC,GACjB,IAAI,CAAA;;AAER,WAAS,KAAK,CAAC,GAAG,EAAE;AAClB,WAAO,GAAG,CAAA;GACX;;AAED,SAAO,SAAS,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE;AACxC,QAAI,GAAG,CAAC,KAAK,EAAE;AACb,cAAO,KAAK,CAAC,qBAAqB,CAAC,EAAE,IAAI,EAAE,CAAA,CAAA;KAC5C;;AAED,OAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,IAAI,EAAE,CAAA;;;AAGzB,QAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AACxB,cAAO,KAAK,CAAC,iBAAiB,CAAC,EAAE,IAAI,EAAE,CAAA,CAAA;KACxC;;AAED,SAAK,CAAC,iBAAiB,EAAE,GAAG,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAA;;;AAGrD,QAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;AACrB,cAAO,KAAK,CAAC,cAAc,CAAC,EAAE,IAAI,EAAE,CAAA,CAAA;KACrC;;;AAGD,QAAI,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE;AACjC,cAAQ,EAAE,IAAI;AACd,aAAO,EAAE,OAAO;AAChB,WAAK,EAAE,KAAK;AACZ,YAAM,EAAE,MAAM;KACf,CAAC,CAAA;GACH,CAAA;CACF;;;;;;;;;AASD,SAAS,WAAW,CAAC,IAAI,EAAE;AACzB,SAAO,SAAS,SAAS,CAAC,GAAG,EAAE;AAC7B,WAAO,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAA;GAClC,CAAA;CACF","file":"raw-compiled.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw(options) {\n  var opts = options || {};\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse(buf) {\n    return buf\n  }\n\n  return function rawParser(req, res, next) {\n    if (req._body) {\n      return debug('body already parsed'), next()\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      return debug('skip empty body'), next()\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      return debug('skip parsing'), next()\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}