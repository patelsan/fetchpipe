{"version":3,"sources":["urlencoded.js"],"names":[],"mappings":"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","file":"urlencoded-compiled.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded(options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse(body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      return debug('body already parsed'), next()\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      return debug('skip empty body'), next()\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      return debug('skip parsing'), next()\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters')\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return contentType.parse(req).parameters.charset.toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount(body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser(name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters')\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, {maxKeys: parameterLimit})\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}