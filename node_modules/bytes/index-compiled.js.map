{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: ((1 << 30) * 1024)\n};\n\n/**\n *Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  thousandsSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {string} [options.thousandsSeparator=]\n * @public\n */\n\nfunction format(val, options) {\n  if (typeof val !== 'number') {\n    return null;\n  }\n\n  var mag = Math.abs(val);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unit = 'B';\n  var value = val;\n\n  if (mag >= map.tb) {\n    value = Math.round(value / map.tb * 100) / 100;\n    unit = 'TB';\n  } else if (mag >= map.gb) {\n    value = Math.round(value / map.gb * 100) / 100;\n    unit = 'GB';\n  } else if (mag >= map.mb) {\n    value = Math.round(value / map.mb * 100) / 100;\n    unit = 'MB';\n  } else if (mag >= map.kb) {\n    value = Math.round(value / map.kb * 100) / 100;\n    unit = 'kB';\n  }\n\n  if (thousandsSeparator) {\n    value = value.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousandsSeparator);\n  }\n\n  return value + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = val.match(/^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb)$/i);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  return map[unit] * floatValue;\n}\n"]}