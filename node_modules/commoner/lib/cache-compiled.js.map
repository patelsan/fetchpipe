{"version":3,"sources":["cache.js"],"names":[],"mappings":"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","file":"cache-compiled.js","sourcesContent":["var assert = require(\"assert\");\nvar Q = require(\"q\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar util = require(\"./util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * ReadFileCache is an EventEmitter subclass that caches file contents in\n * memory so that subsequent calls to readFileP return the same contents,\n * regardless of any changes in the underlying file.\n */\nfunction ReadFileCache(sourceDir, charset) {\n    assert.ok(this instanceof ReadFileCache);\n    assert.strictEqual(typeof sourceDir, \"string\");\n\n    this.charset = charset;\n\n    EventEmitter.call(this);\n\n    Object.defineProperties(this, {\n        sourceDir: { value: sourceDir },\n        sourceCache: { value: {} }\n    });\n}\n\nutil.inherits(ReadFileCache, EventEmitter);\nvar RFCp = ReadFileCache.prototype;\n\n/**\n * Read a file from the cache if possible, else from disk.\n */\nRFCp.readFileP = function(relativePath) {\n    var cache = this.sourceCache;\n\n    relativePath = path.normalize(relativePath);\n\n    return hasOwn.call(cache, relativePath)\n        ? cache[relativePath]\n        : this.noCacheReadFileP(relativePath);\n};\n\n/**\n * Read (or re-read) a file without using the cache.\n *\n * The new contents are stored in the cache for any future calls to\n * readFileP.\n */\nRFCp.noCacheReadFileP = function(relativePath) {\n    relativePath = path.normalize(relativePath);\n\n    var added = !hasOwn.call(this.sourceCache, relativePath);\n    var promise = this.sourceCache[relativePath] = util.readFileP(\n        path.join(this.sourceDir, relativePath), this.charset);\n\n    if (added) {\n        this.emit(\"added\", relativePath);\n    }\n\n    return promise;\n};\n\n/**\n * If you have reason to believe the contents of a file have changed, call\n * this method to re-read the file and compare the new contents to the\n * cached contents.  If the new contents differ from the contents of the\n * cache, the \"changed\" event will be emitted.\n */\nRFCp.reportPossiblyChanged = function(relativePath) {\n    var self = this;\n    var cached = self.readFileP(relativePath);\n    var fresh = self.noCacheReadFileP(relativePath);\n\n    Q.spread([\n        cached.catch(orNull),\n        fresh.catch(orNull)\n    ], function(oldData, newData) {\n        if (oldData !== newData) {\n            self.emit(\"changed\", relativePath);\n        }\n    }).done();\n};\n\n/**\n * Invoke the given callback for all files currently known to the\n * ReadFileCache, and invoke it in the future when any new files become\n * known to the cache.\n */\nRFCp.subscribe = function(callback, context) {\n    for (var relativePath in this.sourceCache) {\n        if (hasOwn.call(this.sourceCache, relativePath)) {\n            callback.call(context || null, relativePath);\n        }\n    }\n\n    this.on(\"added\", function(relativePath) {\n        callback.call(context || null, relativePath);\n    });\n};\n\n/**\n * Avoid memory leaks by removing listeners and emptying the cache.\n */\nRFCp.clear = function() {\n    this.removeAllListeners();\n\n    for (var relativePath in this.sourceCache) {\n        delete this.sourceCache[relativePath];\n    }\n};\n\nfunction orNull(err) {\n    return null;\n}\n\nexports.ReadFileCache = ReadFileCache;\n"]}