{"version":3,"sources":["defs-main.js"],"names":[],"mappings":"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","file":"defs-main-compiled.js","sourcesContent":["\"use strict\";\n\nvar assert = require(\"assert\");\nvar is = require(\"simple-is\");\nvar fmt = require(\"simple-fmt\");\nvar stringmap = require(\"stringmap\");\nvar stringset = require(\"stringset\");\nvar alter = require(\"alter\");\nvar traverse = require(\"ast-traverse\");\nvar breakable = require(\"breakable\");\nvar Scope = require(\"./scope\");\nvar error = require(\"./error\");\nvar getline = error.getline;\nvar options = require(\"./options\");\nvar Stats = require(\"./stats\");\nvar jshint_vars = require(\"./jshint_globals/vars.js\");\n\n\nfunction isConstLet(kind) {\n    return is.someof(kind, [\"const\", \"let\"]);\n}\n\nfunction isVarConstLet(kind) {\n    return is.someof(kind, [\"var\", \"const\", \"let\"]);\n}\n\nfunction isNonFunctionBlock(node) {\n    return node.type === \"BlockStatement\" && is.noneof(node.$parent.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isForWithConstLet(node) {\n    return node.type === \"ForStatement\" && node.init && node.init.type === \"VariableDeclaration\" && isConstLet(node.init.kind);\n}\n\nfunction isForInOfWithConstLet(node) {\n    return isForInOf(node) && node.left.type === \"VariableDeclaration\" && isConstLet(node.left.kind);\n}\n\nfunction isForInOf(node) {\n    return is.someof(node.type, [\"ForInStatement\", \"ForOfStatement\"]);\n}\n\nfunction isFunction(node) {\n    return is.someof(node.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isLoop(node) {\n    return is.someof(node.type, [\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\"]);\n}\n\nfunction isReference(node) {\n    var parent = node.$parent;\n    return node.$refToScope ||\n        node.type === \"Identifier\" &&\n        !(parent.type === \"VariableDeclarator\" && parent.id === node) && // var|let|const $\n        !(parent.type === \"MemberExpression\" && parent.computed === false && parent.property === node) && // obj.$\n        !(parent.type === \"Property\" && parent.key === node) && // {$: ...}\n        !(parent.type === \"LabeledStatement\" && parent.label === node) && // $: ...\n        !(parent.type === \"CatchClause\" && parent.param === node) && // catch($)\n        !(isFunction(parent) && parent.id === node) && // function $(..\n        !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..\n        true;\n}\n\nfunction isLvalue(node) {\n    return isReference(node) &&\n        ((node.$parent.type === \"AssignmentExpression\" && node.$parent.left === node) ||\n            (node.$parent.type === \"UpdateExpression\" && node.$parent.argument === node));\n}\n\nfunction createScopes(node, parent) {\n    assert(!node.$scope);\n\n    node.$parent = parent;\n    node.$scope = node.$parent ? node.$parent.$scope : null; // may be overridden\n\n    if (node.type === \"Program\") {\n        // Top-level program is a scope\n        // There's no block-scope under it\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: null,\n        });\n\n    } else if (isFunction(node)) {\n        // Function is a scope, with params in it\n        // There's no block-scope under it\n\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n        // function has a name\n        if (node.id) {\n            assert(node.id.type === \"Identifier\");\n\n            if (node.type === \"FunctionDeclaration\") {\n                // Function name goes in parent scope for declared functions\n                node.$parent.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else if (node.type === \"FunctionExpression\") {\n                // Function name goes in function's scope for named function expressions\n                node.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else {\n                assert(false);\n            }\n        }\n\n        node.params.forEach(function(param) {\n            node.$scope.add(param.name, \"param\", param, null);\n        });\n\n    } else if (node.type === \"VariableDeclaration\") {\n        // Variable declarations names goes in current scope\n        assert(isVarConstLet(node.kind));\n        node.declarations.forEach(function(declarator) {\n            assert(declarator.type === \"VariableDeclarator\");\n            var name = declarator.id.name;\n            if (options.disallowVars && node.kind === \"var\") {\n                error(getline(declarator), \"var {0} is not allowed (use let or const)\", name);\n            }\n            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);\n        });\n\n    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {\n        // For(In/Of) loop with const|let declaration is a scope, with declaration in it\n        // There may be a block-scope under it\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (isNonFunctionBlock(node)) {\n        // A block node is a scope unless parent is a function\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (node.type === \"CatchClause\") {\n        var identifier = node.param;\n\n        node.$scope = new Scope({\n            kind: \"catch-block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n        node.$scope.add(identifier.name, \"caught\", identifier, null);\n\n        // All hoist-scope keeps track of which variables that are propagated through,\n        // i.e. an reference inside the scope points to a declaration outside the scope.\n        // This is used to mark \"taint\" the name since adding a new variable in the scope,\n        // with a propagated name, would change the meaning of the existing references.\n        //\n        // catch(e) is special because even though e is a variable in its own scope,\n        // we want to make sure that catch(e){let e} is never transformed to\n        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e\n        // in the closest hoist-scope, i.e. where var e$0 belongs.\n        node.$scope.closestHoistScope().markPropagates(identifier.name);\n    }\n}\n\nfunction createTopScope(programScope, environments, globals) {\n    function inject(obj) {\n        for (var name in obj) {\n            var writeable = obj[name];\n            var kind = (writeable ? \"var\" : \"const\");\n            if (topScope.hasOwn(name)) {\n                topScope.remove(name);\n            }\n            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);\n        }\n    }\n\n    var topScope = new Scope({\n        kind: \"hoist\",\n        node: {},\n        parent: null,\n    });\n\n    var complementary = {\n        undefined: false,\n        Infinity: false,\n        console: false,\n    };\n\n    inject(complementary);\n    inject(jshint_vars.reservedVars);\n    inject(jshint_vars.ecmaIdentifiers);\n    if (environments) {\n        environments.forEach(function(env) {\n            if (!jshint_vars[env]) {\n                error(-1, 'environment \"{0}\" not found', env);\n            } else {\n                inject(jshint_vars[env]);\n            }\n        });\n    }\n    if (globals) {\n        inject(globals);\n    }\n\n    // link it in\n    programScope.parent = topScope;\n    topScope.children.push(programScope);\n\n    return topScope;\n}\n\nfunction setupReferences(ast, allIdentifiers, opts) {\n    var analyze = (is.own(opts, \"analyze\") ? opts.analyze : true);\n\n    function visit(node) {\n        if (!isReference(node)) {\n            return;\n        }\n        allIdentifiers.add(node.name);\n\n        var scope = node.$scope.lookup(node.name);\n        if (analyze && !scope && options.disallowUnknownReferences) {\n            error(getline(node), \"reference to unknown global variable {0}\", node.name);\n        }\n        // check const and let for referenced-before-declaration\n        if (analyze && scope && is.someof(scope.getKind(node.name), [\"const\", \"let\"])) {\n            var allowedFromPos = scope.getFromPos(node.name);\n            var referencedAtPos = node.range[0];\n            assert(is.finitenumber(allowedFromPos));\n            assert(is.finitenumber(referencedAtPos));\n            if (referencedAtPos < allowedFromPos) {\n                if (!node.$scope.hasFunctionScopeBetween(scope)) {\n                    error(getline(node), \"{0} is referenced before its declaration\", node.name);\n                }\n            }\n        }\n        node.$refToScope = scope;\n    }\n\n    traverse(ast, {pre: visit});\n}\n\n// TODO for loops init and body props are parallel to each other but init scope is outer that of body\n// TODO is this a problem?\n\nfunction varify(ast, stats, allIdentifiers, changes) {\n    function unique(name) {\n        assert(allIdentifiers.has(name));\n        for (var cnt = 0; ; cnt++) {\n            var genName = name + \"$\" + String(cnt);\n            if (!allIdentifiers.has(genName)) {\n                return genName;\n            }\n        }\n    }\n\n    function renameDeclarations(node) {\n        if (node.type === \"VariableDeclaration\" && isConstLet(node.kind)) {\n            var hoistScope = node.$scope.closestHoistScope();\n            var origScope = node.$scope;\n\n            // text change const|let => var\n            changes.push({\n                start: node.range[0],\n                end: node.range[0] + node.kind.length,\n                str: \"var\",\n            });\n\n            node.declarations.forEach(function(declarator) {\n                assert(declarator.type === \"VariableDeclarator\");\n                var name = declarator.id.name;\n\n                stats.declarator(node.kind);\n\n                // rename if\n                // 1) name already exists in hoistScope, or\n                // 2) name is already propagated (passed) through hoistScope or manually tainted\n                var rename = (origScope !== hoistScope &&\n                    (hoistScope.hasOwn(name) || hoistScope.doesPropagate(name)));\n\n                var newName = (rename ? unique(name) : name);\n\n                origScope.remove(name);\n                hoistScope.add(newName, \"var\", declarator.id, declarator.range[1]);\n\n                origScope.moves = origScope.moves || stringmap();\n                origScope.moves.set(name, {\n                    name: newName,\n                    scope: hoistScope,\n                });\n\n                allIdentifiers.add(newName);\n\n                if (newName !== name) {\n                    stats.rename(name, newName, getline(declarator));\n\n                    declarator.id.originalName = name;\n                    declarator.id.name = newName;\n\n                    // textchange var x => var x$1\n                    changes.push({\n                        start: declarator.id.range[0],\n                        end: declarator.id.range[1],\n                        str: newName,\n                    });\n                }\n            });\n\n            // ast change const|let => var\n            node.kind = \"var\";\n        }\n    }\n\n    function renameReferences(node) {\n        if (!node.$refToScope) {\n            return;\n        }\n        var move = node.$refToScope.moves && node.$refToScope.moves.get(node.name);\n        if (!move) {\n            return;\n        }\n        node.$refToScope = move.scope;\n\n        if (node.name !== move.name) {\n            node.originalName = node.name;\n            node.name = move.name;\n\n            if (node.alterop) {\n                // node has no range because it is the result of another alter operation\n                var existingOp = null;\n                for (var i = 0; i < changes.length; i++) {\n                    var op = changes[i];\n                    if (op.node === node) {\n                        existingOp = op;\n                        break;\n                    }\n                }\n                assert(existingOp);\n\n                // modify op\n                existingOp.str = move.name;\n            } else {\n                changes.push({\n                    start: node.range[0],\n                    end: node.range[1],\n                    str: move.name,\n                });\n            }\n        }\n    }\n\n    traverse(ast, {pre: renameDeclarations});\n    traverse(ast, {pre: renameReferences});\n    ast.$scope.traverse({pre: function(scope) {\n        delete scope.moves;\n    }});\n}\n\n\nfunction detectLoopClosures(ast) {\n    traverse(ast, {pre: visit});\n\n    function detectIifyBodyBlockers(body, node) {\n        return breakable(function(brk) {\n            traverse(body, {pre: function(n) {\n                // if we hit an inner function of the loop body, don't traverse further\n                if (isFunction(n)) {\n                    return false;\n                }\n\n                var err = true; // reset to false in else-statement below\n                var msg = \"loop-variable {0} is captured by a loop-closure that can't be transformed due to use of {1} at line {2}\";\n                if (n.type === \"BreakStatement\") {\n                    error(getline(node), msg, node.name, \"break\", getline(n));\n                } else if (n.type === \"ContinueStatement\") {\n                    error(getline(node), msg, node.name, \"continue\", getline(n));\n                } else if (n.type === \"ReturnStatement\") {\n                    error(getline(node), msg, node.name, \"return\", getline(n));\n                } else if (n.type === \"YieldExpression\") {\n                    error(getline(node), msg, node.name, \"yield\", getline(n));\n                } else if (n.type === \"Identifier\" && n.name === \"arguments\") {\n                    error(getline(node), msg, node.name, \"arguments\", getline(n));\n                } else if (n.type === \"VariableDeclaration\" && n.kind === \"var\") {\n                    error(getline(node), msg, node.name, \"var\", getline(n));\n                } else {\n                    err = false;\n                }\n                if (err) {\n                    brk(true); // break traversal\n                }\n            }});\n            return false;\n        });\n    }\n\n    function visit(node) {\n        // forbidden pattern:\n        // <any>* <loop> <non-fn>* <constlet-def> <any>* <fn> <any>* <constlet-ref>\n        var loopNode = null;\n        if (isReference(node) && node.$refToScope && isConstLet(node.$refToScope.getKind(node.name))) {\n            // traverse nodes up towards root from constlet-def\n            // if we hit a function (before a loop) - ok!\n            // if we hit a loop - maybe-ouch\n            // if we reach root - ok!\n            for (var n = node.$refToScope.node; ; ) {\n                if (isFunction(n)) {\n                    // we're ok (function-local)\n                    return;\n                } else if (isLoop(n)) {\n                    loopNode = n;\n                    // maybe not ok (between loop and function)\n                    break;\n                }\n                n = n.$parent;\n                if (!n) {\n                    // ok (reached root)\n                    return;\n                }\n            }\n\n            assert(isLoop(loopNode));\n\n            // traverse scopes from reference-scope up towards definition-scope\n            // if we hit a function, ouch!\n            var defScope = node.$refToScope;\n            var generateIIFE = (options.loopClosures === \"iife\");\n\n            for (var s = node.$scope; s; s = s.parent) {\n                if (s === defScope) {\n                    // we're ok\n                    return;\n                } else if (isFunction(s.node)) {\n                    // not ok (there's a function between the reference and definition)\n                    // may be transformable via IIFE\n\n                    if (!generateIIFE) {\n                        var msg = \"loop-variable {0} is captured by a loop-closure. Tried \\\"loopClosures\\\": \\\"iife\\\" in defs-config.json?\";\n                        return error(getline(node), msg, node.name);\n                    }\n\n                    // here be dragons\n                    // for (let x = ..; .. ; ..) { (function(){x})() } is forbidden because of current\n                    // spec and VM status\n                    if (loopNode.type === \"ForStatement\" && defScope.node === loopNode) {\n                        var declarationNode = defScope.getNode(node.name);\n                        return error(getline(declarationNode), \"Not yet specced ES6 feature. {0} is declared in for-loop header and then captured in loop closure\", declarationNode.name);\n                    }\n\n                    // speak now or forever hold your peace\n                    if (detectIifyBodyBlockers(loopNode.body, node)) {\n                        // error already generated\n                        return;\n                    }\n\n                    // mark loop for IIFE-insertion\n                    loopNode.$iify = true;\n                }\n            }\n        }\n    }\n}\n\nfunction transformLoopClosures(root, ops, options) {\n    function insertOp(pos, str, node) {\n        var op = {\n            start: pos,\n            end: pos,\n            str: str,\n        }\n        if (node) {\n            op.node = node;\n        }\n        ops.push(op);\n    }\n\n    traverse(root, {pre: function(node) {\n        if (!node.$iify) {\n            return;\n        }\n\n        var hasBlock = (node.body.type === \"BlockStatement\");\n\n        var insertHead = (hasBlock ?\n            node.body.range[0] + 1 : // just after body {\n            node.body.range[0]); // just before existing expression\n        var insertFoot = (hasBlock ?\n            node.body.range[1] - 1 : // just before body }\n            node.body.range[1]);  // just after existing expression\n\n        var forInName = (isForInOf(node) && node.left.declarations[0].id.name);;\n        var iifeHead = fmt(\"(function({0}){\", forInName ? forInName : \"\");\n        var iifeTail = fmt(\"}).call(this{0});\", forInName ? \", \" + forInName : \"\");\n\n        // modify AST\n        var iifeFragment = options.parse(iifeHead + iifeTail);\n        var iifeExpressionStatement = iifeFragment.body[0];\n        var iifeBlockStatement = iifeExpressionStatement.expression.callee.object.body;\n\n        if (hasBlock) {\n            var forBlockStatement = node.body;\n            var tmp = forBlockStatement.body;\n            forBlockStatement.body = [iifeExpressionStatement];\n            iifeBlockStatement.body = tmp;\n        } else {\n            var tmp$0 = node.body;\n            node.body = iifeExpressionStatement;\n            iifeBlockStatement.body[0] = tmp$0;\n        }\n\n        // create ops\n        insertOp(insertHead, iifeHead);\n\n        if (forInName) {\n            insertOp(insertFoot, \"}).call(this, \");\n\n            var args = iifeExpressionStatement.expression.arguments;\n            var iifeArgumentIdentifier = args[1];\n            iifeArgumentIdentifier.alterop = true;\n            insertOp(insertFoot, forInName, iifeArgumentIdentifier);\n\n            insertOp(insertFoot, \");\");\n        } else {\n            insertOp(insertFoot, iifeTail);\n        }\n    }});\n}\n\nfunction detectConstAssignment(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope && scope.getKind(node.name) === \"const\") {\n                error(getline(node), \"can't assign to const variable {0}\", node.name);\n            }\n        }\n    }});\n}\n\nfunction detectConstantLets(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope) {\n                scope.markWrite(node.name);\n            }\n        }\n    }});\n\n    ast.$scope.detectUnmodifiedLets();\n}\n\nfunction setupScopeAndReferences(root, opts) {\n    // setup scopes\n    traverse(root, {pre: createScopes});\n    var topScope = createTopScope(root.$scope, options.environments, options.globals);\n\n    // allIdentifiers contains all declared and referenced vars\n    // collect all declaration names (including those in topScope)\n    var allIdentifiers = stringset();\n    topScope.traverse({pre: function(scope) {\n        allIdentifiers.addMany(scope.decls.keys());\n    }});\n\n    // setup node.$refToScope, check for errors.\n    // also collects all referenced names to allIdentifiers\n    setupReferences(root, allIdentifiers, opts);\n    return allIdentifiers;\n}\n\nfunction cleanupTree(root) {\n    traverse(root, {pre: function(node) {\n        for (var prop in node) {\n            if (prop[0] === \"$\") {\n                delete node[prop];\n            }\n        }\n    }});\n}\n\nfunction run(src, config) {\n    // alter the options singleton with user configuration\n    for (var key in config) {\n        options[key] = config[key];\n    }\n\n    var parsed;\n\n    if (is.object(src)) {\n        if (!options.ast) {\n            return {\n                errors: [\n                    \"Can't produce string output when input is an AST. \" +\n                    \"Did you forget to set options.ast = true?\"\n                ],\n            };\n        }\n\n        // Received an AST object as src, so no need to parse it.\n        parsed = src;\n\n    } else if (is.string(src)) {\n        try {\n            parsed = options.parse(src, {\n                loc: true,\n                range: true,\n            });\n        } catch (e) {\n            return {\n                errors: [\n                    fmt(\"line {0} column {1}: Error during input file parsing\\n{2}\\n{3}\",\n                        e.lineNumber,\n                        e.column,\n                        src.split(\"\\n\")[e.lineNumber - 1],\n                        fmt.repeat(\" \", e.column - 1) + \"^\")\n                ],\n            };\n        }\n\n    } else {\n        return {\n            errors: [\"Input was neither an AST object nor a string.\"],\n        };\n    }\n\n    var ast = parsed;\n\n    // TODO detect unused variables (never read)\n    error.reset();\n\n    var allIdentifiers = setupScopeAndReferences(ast, {});\n\n    // static analysis passes\n    detectLoopClosures(ast);\n    detectConstAssignment(ast);\n    //detectConstantLets(ast);\n\n    var changes = [];\n    transformLoopClosures(ast, changes, options);\n\n    //ast.$scope.print(); process.exit(-1);\n\n    if (error.errors.length >= 1) {\n        return {\n            errors: error.errors,\n        };\n    }\n\n    if (changes.length > 0) {\n        cleanupTree(ast);\n        allIdentifiers = setupScopeAndReferences(ast, {analyze: false});\n    }\n    assert(error.errors.length === 0);\n\n    // change constlet declarations to var, renamed if needed\n    // varify modifies the scopes and AST accordingly and\n    // returns a list of change fragments (to use with alter)\n    var stats = new Stats();\n    varify(ast, stats, allIdentifiers, changes);\n\n    if (options.ast) {\n        // return the modified AST instead of src code\n        // get rid of all added $ properties first, such as $parent and $scope\n        cleanupTree(ast);\n        return {\n            stats: stats,\n            ast: ast,\n        };\n    } else {\n        // apply changes produced by varify and return the transformed src\n        var transformedSrc = alter(src, changes);\n        return {\n            stats: stats,\n            src: transformedSrc,\n        };\n    }\n}\n\nmodule.exports = run;\n"]}