{"version":3,"sources":["esprima.js"],"names":[],"mappings":"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","file":"esprima-compiled.js","sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true,\nparseClassExpression: true, parseClassDeclaration: true, parseExpression: true,\nparseDeclareClass: true, parseDeclareFunction: true,\nparseDeclareModule: true, parseDeclareVariable: true,\nparseForStatement: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseImportSpecifier: true, parseInterface: true,\nparseLeftHandSideExpression: true, parseParams: true, validateParam: true,\nparseSpreadOrAssignmentExpression: true,\nparseStatement: true, parseSourceElement: true, parseConciseBody: true,\nadvanceXJSChild: true, isXJSIdentifierStart: true, isXJSIdentifierPart: true,\nscanXJSStringLiteral: true, scanXJSIdentifier: true,\nparseXJSAttributeValue: true, parseXJSChild: true, parseXJSElement: true, parseXJSExpressionContainer: true, parseXJSEmptyExpression: true,\nparseFunctionTypeParam: true,\nparsePrimaryType: true,\nparseTypeAlias: true,\nparseType: true, parseTypeAnnotatableIdentifier: true, parseTypeAnnotation: true,\nparseYieldExpression: true, parseAwaitExpression: true\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        XHTMLEntities,\n        ClassPropertyType,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10,\n        XJSIdentifier: 11,\n        XJSText: 12\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.XJSIdentifier] = 'XJSIdentifier';\n    TokenName[Token.XJSText] = 'XJSText';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AnyTypeAnnotation: 'AnyTypeAnnotation',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrayTypeAnnotation: 'ArrayTypeAnnotation',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AssignmentExpression: 'AssignmentExpression',\n        BinaryExpression: 'BinaryExpression',\n        BlockStatement: 'BlockStatement',\n        BooleanTypeAnnotation: 'BooleanTypeAnnotation',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ClassImplements: 'ClassImplements',\n        ClassProperty: 'ClassProperty',\n        ComprehensionBlock: 'ComprehensionBlock',\n        ComprehensionExpression: 'ComprehensionExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DeclareClass: 'DeclareClass',\n        DeclareFunction: 'DeclareFunction',\n        DeclareModule: 'DeclareModule',\n        DeclareVariable: 'DeclareVariable',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportDeclaration: 'ExportDeclaration',\n        ExportBatchSpecifier: 'ExportBatchSpecifier',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        ForStatement: 'ForStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        FunctionTypeAnnotation: 'FunctionTypeAnnotation',\n        FunctionTypeParam: 'FunctionTypeParam',\n        GenericTypeAnnotation: 'GenericTypeAnnotation',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        InterfaceDeclaration: 'InterfaceDeclaration',\n        InterfaceExtends: 'InterfaceExtends',\n        IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',\n        LabeledStatement: 'LabeledStatement',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        NullableTypeAnnotation: 'NullableTypeAnnotation',\n        NumberTypeAnnotation: 'NumberTypeAnnotation',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        ObjectTypeAnnotation: 'ObjectTypeAnnotation',\n        ObjectTypeCallProperty: 'ObjectTypeCallProperty',\n        ObjectTypeIndexer: 'ObjectTypeIndexer',\n        ObjectTypeProperty: 'ObjectTypeProperty',\n        Program: 'Program',\n        Property: 'Property',\n        QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        SpreadProperty: 'SpreadProperty',\n        StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',\n        StringTypeAnnotation: 'StringTypeAnnotation',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TupleTypeAnnotation: 'TupleTypeAnnotation',\n        TryStatement: 'TryStatement',\n        TypeAlias: 'TypeAlias',\n        TypeAnnotation: 'TypeAnnotation',\n        TypeofTypeAnnotation: 'TypeofTypeAnnotation',\n        TypeParameterDeclaration: 'TypeParameterDeclaration',\n        TypeParameterInstantiation: 'TypeParameterInstantiation',\n        UnaryExpression: 'UnaryExpression',\n        UnionTypeAnnotation: 'UnionTypeAnnotation',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        VoidTypeAnnotation: 'VoidTypeAnnotation',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        XJSIdentifier: 'XJSIdentifier',\n        XJSNamespacedName: 'XJSNamespacedName',\n        XJSMemberExpression: 'XJSMemberExpression',\n        XJSEmptyExpression: 'XJSEmptyExpression',\n        XJSExpressionContainer: 'XJSExpressionContainer',\n        XJSElement: 'XJSElement',\n        XJSClosingElement: 'XJSClosingElement',\n        XJSOpeningElement: 'XJSOpeningElement',\n        XJSAttribute: 'XJSAttribute',\n        XJSSpreadAttribute: 'XJSSpreadAttribute',\n        XJSText: 'XJSText',\n        YieldExpression: 'YieldExpression',\n        AwaitExpression: 'AwaitExpression'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    ClassPropertyType = {\n        'static': 'static',\n        prototype: 'prototype'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedTemplate:  'Unexpected quasi %0',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',\n        IllegalReturn: 'Illegal return statement',\n        IllegalSpread: 'Illegal spread element',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',\n        DefaultRestParameter: 'Rest parameter can not have a default value',\n        ElementAfterSpreadElement: 'Spread must be the final element of an element list',\n        PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',\n        ObjectPatternAsRestParameter: 'Invalid rest parameter',\n        ObjectPatternAsSpread: 'Invalid spread argument',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode',\n        MissingFromClause: 'Missing from clause',\n        NoAsAfterImportNamespace: 'Missing as after import *',\n        InvalidModuleSpecifier: 'Invalid module specifier',\n        NoUnintializedConst: 'Const must be initialized',\n        ComprehensionRequiresBlock: 'Comprehension must have at least one block',\n        ComprehensionError:  'Comprehension Error',\n        EachNotAllowed:  'Each is not supported',\n        InvalidXJSAttributeValue: 'XJS value should be either an expression or a quoted XJS text',\n        ExpectedXJSClosingTag: 'Expected corresponding XJS closing tag for %0',\n        AdjacentXJSElements: 'Adjacent XJS elements must be wrapped in an enclosing tag',\n        ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +\n            'you are trying to write a function type, but you ended up ' +\n            'writing a grouped type followed by an =>, which is a syntax ' +\n            'error. Remember, function type parameters are named so function ' +\n            'types look like (name1: type1, name2: type2) => returnType. You ' +\n            'probably wrote (type1) => returnType'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0300-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u0483-\\u0487\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0610-\\u061a\\u0620-\\u0669\\u066e-\\u06d3\\u06d5-\\u06dc\\u06df-\\u06e8\\u06ea-\\u06fc\\u06ff\\u0710-\\u074a\\u074d-\\u07b1\\u07c0-\\u07f5\\u07fa\\u0800-\\u082d\\u0840-\\u085b\\u08a0\\u08a2-\\u08ac\\u08e4-\\u08fe\\u0900-\\u0963\\u0966-\\u096f\\u0971-\\u0977\\u0979-\\u097f\\u0981-\\u0983\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bc-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09ce\\u09d7\\u09dc\\u09dd\\u09df-\\u09e3\\u09e6-\\u09f1\\u0a01-\\u0a03\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a59-\\u0a5c\\u0a5e\\u0a66-\\u0a75\\u0a81-\\u0a83\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abc-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ad0\\u0ae0-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3c-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5c\\u0b5d\\u0b5f-\\u0b63\\u0b66-\\u0b6f\\u0b71\\u0b82\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd0\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c58\\u0c59\\u0c60-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbc-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0cde\\u0ce0-\\u0ce3\\u0ce6-\\u0cef\\u0cf1\\u0cf2\\u0d02\\u0d03\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4e\\u0d57\\u0d60-\\u0d63\\u0d66-\\u0d6f\\u0d7a-\\u0d7f\\u0d82\\u0d83\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e01-\\u0e3a\\u0e40-\\u0e4e\\u0e50-\\u0e59\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb9\\u0ebb-\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0edc-\\u0edf\\u0f00\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e-\\u0f47\\u0f49-\\u0f6c\\u0f71-\\u0f84\\u0f86-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1049\\u1050-\\u109d\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u135d-\\u135f\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176c\\u176e-\\u1770\\u1772\\u1773\\u1780-\\u17d3\\u17d7\\u17dc\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a1b\\u1a20-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1aa7\\u1b00-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1bf3\\u1c00-\\u1c37\\u1c40-\\u1c49\\u1c4d-\\u1c7d\\u1cd0-\\u1cd2\\u1cd4-\\u1cf6\\u1d00-\\u1de6\\u1dfc-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u200c\\u200d\\u203f\\u2040\\u2054\\u2071\\u207f\\u2090-\\u209c\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d7f-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2de0-\\u2dff\\u2e2f\\u3005-\\u3007\\u3021-\\u302f\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u3099\\u309a\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua62b\\ua640-\\ua66f\\ua674-\\ua67d\\ua67f-\\ua697\\ua69f-\\ua6f1\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua827\\ua840-\\ua873\\ua880-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f7\\ua8fb\\ua900-\\ua92d\\ua930-\\ua953\\ua960-\\ua97c\\ua980-\\ua9c0\\ua9cf-\\ua9d9\\uaa00-\\uaa36\\uaa40-\\uaa4d\\uaa50-\\uaa59\\uaa60-\\uaa76\\uaa7a\\uaa7b\\uaa80-\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaef\\uaaf2-\\uaaf6\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff10-\\uff19\\uff21-\\uff3a\\uff3f\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]'),\n        LeadingZeros: new RegExp('^0+(?!$)')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57) ||         // 0..9\n            (ch === 92) ||                    // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' is only treated as a keyword in strict mode.\n        // 'let' is for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function skipComment() {\n        var ch, blockComment, lineComment;\n\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (lineComment) {\n                ++index;\n                if (isLineTerminator(ch)) {\n                    lineComment = false;\n                    if (ch === 13 && source.charCodeAt(index) === 10) {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch)) {\n                    if (ch === 13) {\n                        ++index;\n                    }\n                    if (ch !== 13 || source.charCodeAt(index) === 10) {\n                        ++lineNumber;\n                        ++index;\n                        lineStart = index;\n                        if (index >= length) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                } else {\n                    ch = source.charCodeAt(index++);\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    // Block comment ends with '*/' (char #42, char #47).\n                    if (ch === 42) {\n                        ch = source.charCodeAt(index);\n                        if (ch === 47) {\n                            ++index;\n                            blockComment = false;\n                        }\n                    }\n                }\n            } else if (ch === 47) {\n                ch = source.charCodeAt(index + 1);\n                // Line comment starts with '//' (char #47, char #47).\n                if (ch === 47) {\n                    index += 2;\n                    lineComment = true;\n                } else if (ch === 42) {\n                    // Block comment starts with '/*' (char #47, char #42).\n                    index += 2;\n                    blockComment = true;\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (char #92, char #117) denotes an escaped character.\n        if (ch === 92) {\n            if (source.charCodeAt(index) !== 117) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (char #92, char #117) denotes an escaped character.\n            if (ch === 92) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 117) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 92) {\n                // Blackslash (char #92) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (char #92) starts an escaped character.\n        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n        // Check for most common single-character punctuators.\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n        case 126:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 40) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 123) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 94:  // ^\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '...',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        // Don't match these tokens if we're in a type, since they never can\n        // occur and can mess up types like Map<string, Array<string>>\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '=' && ch2 === '>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: '=>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '.') {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch, octal;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    number = '';\n\n                    while (index < length) {\n                        ch = source[index];\n                        if (ch !== '0' && ch !== '1') {\n                            break;\n                        }\n                        number += source[index++];\n                    }\n\n                    if (number.length === 0) {\n                        // only 0b or 0B\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                    return {\n                        type: Token.NumericLiteral,\n                        value: parseInt(number, 2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                }\n                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {\n                    return scanOctalLiteral(ch, start);\n                }\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;\n\n        terminated = false;\n        tail = false;\n        start = index;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            cooked += String.fromCharCode(code);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))\n            },\n            tail: tail,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanTemplateElement(option) {\n        var startsWith, template;\n\n        lookahead = null;\n        skipComment();\n\n        startsWith = (option.head) ? '`' : '}';\n\n        if (source[index] !== startsWith) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        template = scanTemplate();\n\n        peek();\n\n        return template;\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false, tmp;\n\n        lookahead = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '\\\\') {\n                    ch = source[index++];\n                    // ECMA-262 7.8.5\n                    if (isLineTerminator(ch.charCodeAt(0))) {\n                        throwError({}, Messages.UnterminatedRegExp);\n                    }\n                    str += ch;\n                } else if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                } else if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        tmp = pattern;\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode code point\n            // escape sequence that represents such a symbol with a single\n            // ASCII symbol to avoid throwing on regular expressions that\n            // are only valid in combination with the `/u` flag.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]{5,6})\\}/g, 'x')\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            value = new RegExp(tmp);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (exception) {\n            value = null;\n        }\n\n        peek();\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: pattern,\n                    flags: flags\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n        return {\n            literal: str,\n            value: value,\n            regex: {\n                pattern: pattern,\n                flags: flags\n            },\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return scanRegExp();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return scanRegExp();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return scanRegExp();\n            }\n            return scanRegExp();\n        }\n        if (prevToken.type === 'Keyword') {\n            return scanRegExp();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        if (!state.inXJSChild) {\n            skipComment();\n        }\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        if (state.inXJSChild) {\n            return advanceXJSChild();\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            if (state.inXJSTag) {\n                return scanXJSStringLiteral();\n            }\n            return scanStringLiteral();\n        }\n\n        if (state.inXJSTag && isXJSIdentifierStart(ch)) {\n            return scanXJSIdentifier();\n        }\n\n        if (ch === 96) {\n            return scanTemplate();\n        }\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) char #47 can also start a regex.\n        if (extra.tokenize && ch === 47) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function lookahead2() {\n        var adv, pos, line, start, result;\n\n        // If we are collecting the tokens, don't grab the next one yet.\n        adv = (typeof extra.advance === 'function') ? extra.advance : advance;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n\n        // Scan for the next immediate token.\n        if (lookahead === null) {\n            lookahead = adv();\n        }\n        index = lookahead.range[1];\n        lineNumber = lookahead.lineNumber;\n        lineStart = lookahead.lineStart;\n\n        // Grab the token right after.\n        result = adv();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return result;\n    }\n\n    function rewind(token) {\n        index = token.range[0];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n        lookahead = token;\n    }\n\n    function markerCreate() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        skipComment();\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function markerCreatePreserveWhitespace() {\n        if (!extra.loc && !extra.range) {\n            return undefined;\n        }\n        return {offset: index, line: lineNumber, col: index - lineStart};\n    }\n\n    function processComment(node) {\n        var lastChild,\n            trailingComments,\n            bottomRight = extra.bottomRightStack,\n            last = bottomRight[bottomRight.length - 1];\n\n        if (node.type === Syntax.Program) {\n            if (node.body.length > 0) {\n                return;\n            }\n        }\n\n        if (extra.trailingComments.length > 0) {\n            if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = extra.trailingComments;\n                extra.trailingComments = [];\n            } else {\n                extra.trailingComments.length = 0;\n            }\n        } else {\n            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {\n                trailingComments = last.trailingComments;\n                delete last.trailingComments;\n            }\n        }\n\n        // Eating the stack.\n        if (last) {\n            while (last && last.range[0] >= node.range[0]) {\n                lastChild = last;\n                last = bottomRight.pop();\n            }\n        }\n\n        if (lastChild) {\n            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = lastChild.leadingComments;\n                delete lastChild.leadingComments;\n            }\n        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n            node.leadingComments = extra.leadingComments;\n            extra.leadingComments = [];\n        }\n\n        if (trailingComments) {\n            node.trailingComments = trailingComments;\n        }\n\n        bottomRight.push(node);\n    }\n\n    function markerApply(marker, node) {\n        if (extra.range) {\n            node.range = [marker.offset, index];\n        }\n        if (extra.loc) {\n            node.loc = {\n                start: {\n                    line: marker.line,\n                    column: marker.col\n                },\n                end: {\n                    line: lineNumber,\n                    column: index - lineStart\n                }\n            };\n            node = delegate.postProcess(node);\n        }\n        if (extra.attachComment) {\n            processComment(node);\n        }\n        return node;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        postProcess: function (node) {\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createForOfStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForOfStatement,\n                left: left,\n                right: right,\n                body: body\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,\n                                             isAsync, returnType, typeParameters) {\n            var funDecl = {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funDecl.async = true;\n            }\n\n            return funDecl;\n        },\n\n        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,\n                                            isAsync, returnType, typeParameters) {\n            var funExpr = {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: generator,\n                expression: expression,\n                returnType: returnType,\n                typeParameters: typeParameters\n            };\n\n            if (isAsync) {\n                funExpr.async = true;\n            }\n\n            return funExpr;\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name,\n                // Only here to initialize the shape of the object to ensure\n                // that the 'typeAnnotation' key is ordered before others that\n                // are added later (like 'loc' and 'range'). This just helps\n                // keep the shape of Identifier nodes consistent with everything\n                // else.\n                typeAnnotation: undefined,\n                optional: undefined\n            };\n        },\n\n        createTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.TypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {\n            return {\n                type: Syntax.FunctionTypeAnnotation,\n                params: params,\n                returnType: returnType,\n                rest: rest,\n                typeParameters: typeParameters\n            };\n        },\n\n        createFunctionTypeParam: function (name, typeAnnotation, optional) {\n            return {\n                type: Syntax.FunctionTypeParam,\n                name: name,\n                typeAnnotation: typeAnnotation,\n                optional: optional\n            };\n        },\n\n        createNullableTypeAnnotation: function (typeAnnotation) {\n            return {\n                type: Syntax.NullableTypeAnnotation,\n                typeAnnotation: typeAnnotation\n            };\n        },\n\n        createArrayTypeAnnotation: function (elementType) {\n            return {\n                type: Syntax.ArrayTypeAnnotation,\n                elementType: elementType\n            };\n        },\n\n        createGenericTypeAnnotation: function (id, typeParameters) {\n            return {\n                type: Syntax.GenericTypeAnnotation,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createQualifiedTypeIdentifier: function (qualification, id) {\n            return {\n                type: Syntax.QualifiedTypeIdentifier,\n                qualification: qualification,\n                id: id\n            };\n        },\n\n        createTypeParameterDeclaration: function (params) {\n            return {\n                type: Syntax.TypeParameterDeclaration,\n                params: params\n            };\n        },\n\n        createTypeParameterInstantiation: function (params) {\n            return {\n                type: Syntax.TypeParameterInstantiation,\n                params: params\n            };\n        },\n\n        createAnyTypeAnnotation: function () {\n            return {\n                type: Syntax.AnyTypeAnnotation\n            };\n        },\n\n        createBooleanTypeAnnotation: function () {\n            return {\n                type: Syntax.BooleanTypeAnnotation\n            };\n        },\n\n        createNumberTypeAnnotation: function () {\n            return {\n                type: Syntax.NumberTypeAnnotation\n            };\n        },\n\n        createStringTypeAnnotation: function () {\n            return {\n                type: Syntax.StringTypeAnnotation\n            };\n        },\n\n        createStringLiteralTypeAnnotation: function (token) {\n            return {\n                type: Syntax.StringLiteralTypeAnnotation,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createVoidTypeAnnotation: function () {\n            return {\n                type: Syntax.VoidTypeAnnotation\n            };\n        },\n\n        createTypeofTypeAnnotation: function (argument) {\n            return {\n                type: Syntax.TypeofTypeAnnotation,\n                argument: argument\n            };\n        },\n\n        createTupleTypeAnnotation: function (types) {\n            return {\n                type: Syntax.TupleTypeAnnotation,\n                types: types\n            };\n        },\n\n        createObjectTypeAnnotation: function (properties, indexers, callProperties) {\n            return {\n                type: Syntax.ObjectTypeAnnotation,\n                properties: properties,\n                indexers: indexers,\n                callProperties: callProperties\n            };\n        },\n\n        createObjectTypeIndexer: function (id, key, value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeIndexer,\n                id: id,\n                key: key,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeCallProperty: function (value, isStatic) {\n            return {\n                type: Syntax.ObjectTypeCallProperty,\n                value: value,\n                static: isStatic\n            };\n        },\n\n        createObjectTypeProperty: function (key, value, optional, isStatic) {\n            return {\n                type: Syntax.ObjectTypeProperty,\n                key: key,\n                value: value,\n                optional: optional,\n                static: isStatic\n            };\n        },\n\n        createUnionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.UnionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createIntersectionTypeAnnotation: function (types) {\n            return {\n                type: Syntax.IntersectionTypeAnnotation,\n                types: types\n            };\n        },\n\n        createTypeAlias: function (id, typeParameters, right) {\n            return {\n                type: Syntax.TypeAlias,\n                id: id,\n                typeParameters: typeParameters,\n                right: right\n            };\n        },\n\n        createInterface: function (id, typeParameters, body, extended) {\n            return {\n                type: Syntax.InterfaceDeclaration,\n                id: id,\n                typeParameters: typeParameters,\n                body: body,\n                extends: extended\n            };\n        },\n\n        createInterfaceExtends: function (id, typeParameters) {\n            return {\n                type: Syntax.InterfaceExtends,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createDeclareFunction: function (id) {\n            return {\n                type: Syntax.DeclareFunction,\n                id: id\n            };\n        },\n\n        createDeclareVariable: function (id) {\n            return {\n                type: Syntax.DeclareVariable,\n                id: id\n            };\n        },\n\n        createDeclareModule: function (id, body) {\n            return {\n                type: Syntax.DeclareModule,\n                id: id,\n                body: body\n            };\n        },\n\n        createXJSAttribute: function (name, value) {\n            return {\n                type: Syntax.XJSAttribute,\n                name: name,\n                value: value || null\n            };\n        },\n\n        createXJSSpreadAttribute: function (argument) {\n            return {\n                type: Syntax.XJSSpreadAttribute,\n                argument: argument\n            };\n        },\n\n        createXJSIdentifier: function (name) {\n            return {\n                type: Syntax.XJSIdentifier,\n                name: name\n            };\n        },\n\n        createXJSNamespacedName: function (namespace, name) {\n            return {\n                type: Syntax.XJSNamespacedName,\n                namespace: namespace,\n                name: name\n            };\n        },\n\n        createXJSMemberExpression: function (object, property) {\n            return {\n                type: Syntax.XJSMemberExpression,\n                object: object,\n                property: property\n            };\n        },\n\n        createXJSElement: function (openingElement, closingElement, children) {\n            return {\n                type: Syntax.XJSElement,\n                openingElement: openingElement,\n                closingElement: closingElement,\n                children: children\n            };\n        },\n\n        createXJSEmptyExpression: function () {\n            return {\n                type: Syntax.XJSEmptyExpression\n            };\n        },\n\n        createXJSExpressionContainer: function (expression) {\n            return {\n                type: Syntax.XJSExpressionContainer,\n                expression: expression\n            };\n        },\n\n        createXJSOpeningElement: function (name, attributes, selfClosing) {\n            return {\n                type: Syntax.XJSOpeningElement,\n                name: name,\n                selfClosing: selfClosing,\n                attributes: attributes\n            };\n        },\n\n        createXJSClosingElement: function (name) {\n            return {\n                type: Syntax.XJSClosingElement,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            var object = {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n            if (token.regex) {\n                object.regex = token.regex;\n            }\n            return object;\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value, method, shorthand, computed) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind,\n                method: method,\n                shorthand: shorthand,\n                computed: computed\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        },\n\n        createTemplateElement: function (value, tail) {\n            return {\n                type: Syntax.TemplateElement,\n                value: value,\n                tail: tail\n            };\n        },\n\n        createTemplateLiteral: function (quasis, expressions) {\n            return {\n                type: Syntax.TemplateLiteral,\n                quasis: quasis,\n                expressions: expressions\n            };\n        },\n\n        createSpreadElement: function (argument) {\n            return {\n                type: Syntax.SpreadElement,\n                argument: argument\n            };\n        },\n\n        createSpreadProperty: function (argument) {\n            return {\n                type: Syntax.SpreadProperty,\n                argument: argument\n            };\n        },\n\n        createTaggedTemplateExpression: function (tag, quasi) {\n            return {\n                type: Syntax.TaggedTemplateExpression,\n                tag: tag,\n                quasi: quasi\n            };\n        },\n\n        createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {\n            var arrowExpr = {\n                type: Syntax.ArrowFunctionExpression,\n                id: null,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: rest,\n                generator: false,\n                expression: expression\n            };\n\n            if (isAsync) {\n                arrowExpr.async = true;\n            }\n\n            return arrowExpr;\n        },\n\n        createMethodDefinition: function (propertyType, kind, key, value) {\n            return {\n                type: Syntax.MethodDefinition,\n                key: key,\n                value: value,\n                kind: kind,\n                'static': propertyType === ClassPropertyType.static\n            };\n        },\n\n        createClassProperty: function (key, typeAnnotation, computed, isStatic) {\n            return {\n                type: Syntax.ClassProperty,\n                key: key,\n                typeAnnotation: typeAnnotation,\n                computed: computed,\n                static: isStatic\n            };\n        },\n\n        createClassBody: function (body) {\n            return {\n                type: Syntax.ClassBody,\n                body: body\n            };\n        },\n\n        createClassImplements: function (id, typeParameters) {\n            return {\n                type: Syntax.ClassImplements,\n                id: id,\n                typeParameters: typeParameters\n            };\n        },\n\n        createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassExpression,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {\n            return {\n                type: Syntax.ClassDeclaration,\n                id: id,\n                superClass: superClass,\n                body: body,\n                typeParameters: typeParameters,\n                superTypeParameters: superTypeParameters,\n                implements: implemented\n            };\n        },\n\n        createModuleSpecifier: function (token) {\n            return {\n                type: Syntax.ModuleSpecifier,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createExportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ExportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createExportBatchSpecifier: function () {\n            return {\n                type: Syntax.ExportBatchSpecifier\n            };\n        },\n\n        createImportDefaultSpecifier: function (id) {\n            return {\n                type: Syntax.ImportDefaultSpecifier,\n                id: id\n            };\n        },\n\n        createImportNamespaceSpecifier: function (id) {\n            return {\n                type: Syntax.ImportNamespaceSpecifier,\n                id: id\n            };\n        },\n\n        createExportDeclaration: function (isDefault, declaration, specifiers, source) {\n            return {\n                type: Syntax.ExportDeclaration,\n                'default': !!isDefault,\n                declaration: declaration,\n                specifiers: specifiers,\n                source: source\n            };\n        },\n\n        createImportSpecifier: function (id, name) {\n            return {\n                type: Syntax.ImportSpecifier,\n                id: id,\n                name: name\n            };\n        },\n\n        createImportDeclaration: function (specifiers, source) {\n            return {\n                type: Syntax.ImportDeclaration,\n                specifiers: specifiers,\n                source: source\n            };\n        },\n\n        createYieldExpression: function (argument, delegate) {\n            return {\n                type: Syntax.YieldExpression,\n                argument: argument,\n                delegate: delegate\n            };\n        },\n\n        createAwaitExpression: function (argument) {\n            return {\n                type: Syntax.AwaitExpression,\n                argument: argument\n            };\n        },\n\n        createComprehensionExpression: function (filter, blocks, body) {\n            return {\n                type: Syntax.ComprehensionExpression,\n                filter: filter,\n                blocks: blocks,\n                body: body\n            };\n        }\n\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral || token.type === Token.XJSText) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        if (token.type === Token.Template) {\n            throwError(token, Messages.UnexpectedTemplate, token.value.raw);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword, contextual) {\n        var token = lex();\n        if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||\n                token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified contextual keyword.\n    // If not, an exception will be thrown.\n\n    function expectContextualKeyword(keyword) {\n        return expectKeyword(keyword, true);\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword, contextual) {\n        var expectedType = contextual ? Token.Identifier : Token.Keyword;\n        return lookahead.type === expectedType && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n\n    function matchContextualKeyword(keyword) {\n        return matchKeyword(keyword, true);\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    // Note that 'yield' is treated as a keyword in strict mode, but a\n    // contextual keyword (identifier) in non-strict mode, so we need to\n    // use matchKeyword('yield', false) and matchKeyword('yield', true)\n    // (i.e. matchContextualKeyword) appropriately.\n    function matchYield() {\n        return state.yieldAllowed && matchKeyword('yield', !strict);\n    }\n\n    function matchAsync() {\n        var backtrackToken = lookahead, matches = false;\n\n        if (matchContextualKeyword('async')) {\n            lex(); // Make sure peekLineTerminator() starts after 'async'.\n            matches = !peekLineTerminator();\n            rewind(backtrackToken); // Revert the lex().\n        }\n\n        return matches;\n    }\n\n    function matchAwait() {\n        return state.awaitAllowed && matchContextualKeyword('await');\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    function isAssignableLeftHandSide(expr) {\n        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true, body,\n            marker = markerCreate();\n\n        expect('[');\n        while (!match(']')) {\n            if (lookahead.value === 'for' &&\n                    lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                matchKeyword('for');\n                tmp = parseForStatement({ignoreBody: true});\n                tmp.of = tmp.type === Syntax.ForOfStatement;\n                tmp.type = Syntax.ComprehensionBlock;\n                if (tmp.left.kind) { // can't be let or const\n                    throwError({}, Messages.ComprehensionError);\n                }\n                blocks.push(tmp);\n            } else if (lookahead.value === 'if' &&\n                           lookahead.type === Token.Keyword) {\n                if (!possiblecomprehension) {\n                    throwError({}, Messages.ComprehensionError);\n                }\n                expectKeyword('if');\n                expect('(');\n                filter = parseExpression();\n                expect(')');\n            } else if (lookahead.value === ',' &&\n                           lookahead.type === Token.Punctuator) {\n                possiblecomprehension = false; // no longer allowed.\n                lex();\n                elements.push(null);\n            } else {\n                tmp = parseSpreadOrAssignmentExpression();\n                elements.push(tmp);\n                if (tmp && tmp.type === Syntax.SpreadElement) {\n                    if (!match(']')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {\n                    expect(','); // this lexes.\n                    possiblecomprehension = false;\n                }\n            }\n        }\n\n        expect(']');\n\n        if (filter && !blocks.length) {\n            throwError({}, Messages.ComprehensionRequiresBlock);\n        }\n\n        if (blocks.length) {\n            if (elements.length !== 1) {\n                throwError({}, Messages.ComprehensionError);\n            }\n            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));\n        }\n        return markerApply(marker, delegate.createArrayExpression(elements));\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(options) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            params, defaults, body, marker = markerCreate();\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = options.generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = options.async;\n        params = options.params || [];\n        defaults = options.defaults || [];\n\n        body = parseConciseBody();\n        if (options.name && strict && isRestrictedWord(params[0].name)) {\n            throwErrorTolerant(options.name, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createFunctionExpression(\n            null,\n            params,\n            defaults,\n            body,\n            options.rest || null,\n            options.generator,\n            body.type !== Syntax.BlockStatement,\n            options.async,\n            options.returnType,\n            options.typeParameters\n        ));\n    }\n\n\n    function parsePropertyMethodFunction(options) {\n        var previousStrict, tmp, method;\n\n        previousStrict = strict;\n        strict = true;\n\n        tmp = parseParams();\n\n        if (tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, tmp.message);\n        }\n\n        method = parsePropertyFunction({\n            params: tmp.params,\n            defaults: tmp.defaults,\n            rest: tmp.rest,\n            generator: options.generator,\n            async: options.async,\n            returnType: tmp.returnType,\n            typeParameters: options.typeParameters\n        });\n\n        strict = previousStrict;\n\n        return method;\n    }\n\n\n    function parseObjectPropertyKey() {\n        var marker = markerCreate(),\n            token = lex(),\n            propertyKey,\n            result;\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (token.type === Token.Punctuator && token.value === '[') {\n            // For computed properties we should skip the [ and ], and\n            // capture in marker only the assignment expression itself.\n            marker = markerCreate();\n            propertyKey = parseAssignmentExpression();\n            result = markerApply(marker, propertyKey);\n            expect(']');\n            return result;\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param, expr, computed,\n            marker = markerCreate(), returnType;\n\n        token = lookahead;\n        computed = (token.value === '[');\n\n        if (token.type === Token.Identifier || computed || matchAsync()) {\n            id = parseObjectPropertyKey();\n\n            if (match(':')) {\n                lex();\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parseAssignmentExpression(),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (match('(')) {\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        id,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: false\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'get',\n                        key,\n                        parsePropertyFunction({\n                            generator: false,\n                            async: false,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'set') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                expect('(');\n                token = lookahead;\n                param = [ parseTypeAnnotatableIdentifier() ];\n                expect(')');\n                if (match(':')) {\n                    returnType = parseTypeAnnotation();\n                }\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'set',\n                        key,\n                        parsePropertyFunction({\n                            params: param,\n                            generator: false,\n                            async: false,\n                            name: token,\n                            returnType: returnType\n                        }),\n                        false,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (token.value === 'async') {\n                computed = (lookahead.value === '[');\n                key = parseObjectPropertyKey();\n\n                return markerApply(\n                    marker,\n                    delegate.createProperty(\n                        'init',\n                        key,\n                        parsePropertyMethodFunction({\n                            generator: false,\n                            async: true\n                        }),\n                        true,\n                        false,\n                        computed\n                    )\n                );\n            }\n\n            if (computed) {\n                // Computed properties can only be used with full notation.\n                throwUnexpected(lookahead);\n            }\n\n            return markerApply(\n                marker,\n                delegate.createProperty('init', id, id, false, true, false)\n            );\n        }\n\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            if (!match('*')) {\n                throwUnexpected(token);\n            }\n            lex();\n\n            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');\n\n            id = parseObjectPropertyKey();\n\n            if (!match('(')) {\n                throwUnexpected(lex());\n            }\n\n            return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: true }), true, false, computed));\n        }\n        key = parseObjectPropertyKey();\n        if (match(':')) {\n            lex();\n            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));\n        }\n        if (match('(')) {\n            return markerApply(marker, delegate.createProperty('init', key, parsePropertyMethodFunction({ generator: false }), true, false, false));\n        }\n        throwUnexpected(lex());\n    }\n\n    function parseObjectSpreadProperty() {\n        var marker = markerCreate();\n        expect('...');\n        return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String,\n            marker = markerCreate();\n\n        expect('{');\n\n        while (!match('}')) {\n            if (match('...')) {\n                property = parseObjectSpreadProperty();\n            } else {\n                property = parseObjectProperty();\n\n                if (property.key.type === Syntax.Identifier) {\n                    name = property.key.name;\n                } else {\n                    name = toString(property.key.value);\n                }\n                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n                key = '$' + name;\n                if (Object.prototype.hasOwnProperty.call(map, key)) {\n                    if (map[key] === PropertyKind.Data) {\n                        if (strict && kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                        } else if (kind !== PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        }\n                    } else {\n                        if (kind === PropertyKind.Data) {\n                            throwErrorTolerant({}, Messages.AccessorDataProperty);\n                        } else if (map[key] & kind) {\n                            throwErrorTolerant({}, Messages.AccessorGetSet);\n                        }\n                    }\n                    map[key] |= kind;\n                } else {\n                    map[key] = kind;\n                }\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createObjectExpression(properties));\n    }\n\n    function parseTemplateElement(option) {\n        var marker = markerCreate(),\n            token = scanTemplateElement(option);\n        if (strict && token.octal) {\n            throwError(token, Messages.StrictOctalLiteral);\n        }\n        return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, marker = markerCreate();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        ++state.parenthesizedCount;\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n    function matchAsyncFuncExprOrDecl() {\n        var token;\n\n        if (matchAsync()) {\n            token = lookahead2();\n            if (token.type === Token.Keyword && token.value === 'function') {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var marker, type, token, expr;\n\n        type = lookahead.type;\n\n        if (type === Token.Identifier) {\n            marker = markerCreate();\n            return markerApply(marker, delegate.createIdentifier(lex().value));\n        }\n\n        if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(lex()));\n        }\n\n        if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createThisExpression());\n            }\n\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n\n            if (matchKeyword('super')) {\n                marker = markerCreate();\n                lex();\n                return markerApply(marker, delegate.createIdentifier('super'));\n            }\n        }\n\n        if (type === Token.BooleanLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = (token.value === 'true');\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (type === Token.NullLiteral) {\n            marker = markerCreate();\n            token = lex();\n            token.value = null;\n            return markerApply(marker, delegate.createLiteral(token));\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('/') || match('/=')) {\n            marker = markerCreate();\n            return markerApply(marker, delegate.createLiteral(scanRegExp()));\n        }\n\n        if (type === Token.Template) {\n            return parseTemplateLiteral();\n        }\n\n        if (match('<')) {\n            return parseXJSElement();\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [], arg;\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                arg = parseSpreadOrAssignmentExpression();\n                args.push(arg);\n\n                if (match(')')) {\n                    break;\n                } else if (arg.type === Syntax.SpreadElement) {\n                    throwError({}, Messages.ElementAfterSpreadElement);\n                }\n\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseSpreadOrAssignmentExpression() {\n        if (match('...')) {\n            var marker = markerCreate();\n            lex();\n            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseNonComputedProperty() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, marker = markerCreate();\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return markerApply(marker, delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = markerApply(marker, delegate.createCallExpression(expr, args));\n            } else if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, marker = markerCreate();\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[') || lookahead.type === Token.Template) {\n            if (match('[')) {\n                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));\n            } else if (match('.')) {\n                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));\n            } else {\n                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var marker = markerCreate(),\n            expr = parseLeftHandSideExpressionAllowCall(),\n            token;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return expr;\n        }\n\n        if ((match('++') || match('--')) && !peekLineTerminator()) {\n            // 11.3.1, 11.3.2\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPostfix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            token = lex();\n            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var marker, token, expr;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            return parsePostfixExpression();\n        }\n\n        if (match('++') || match('--')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (match('+') || match('-') || match('~') || match('!')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n        }\n\n        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            marker = markerCreate();\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n            return expr;\n        }\n\n        return parsePostfixExpression();\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,\n            marker, markers;\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n\n        marker = markerCreate();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, previousAllowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, markerCreate()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                markerApply(marker, expr);\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(markerCreate());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        state.allowIn = previousAllowIn;\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            markerApply(marker, expr);\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function reinterpretAsAssignmentBindingPattern(expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInAssignment);\n                    }\n                    reinterpretAsAssignmentBindingPattern(property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsAssignmentBindingPattern(element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            if (isRestrictedWord(expr.name)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        } else if (expr.type === Syntax.SpreadElement) {\n            reinterpretAsAssignmentBindingPattern(expr.argument);\n            if (expr.argument.type === Syntax.ObjectPattern) {\n                throwError({}, Messages.ObjectPatternAsSpread);\n            }\n        } else {\n            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n        }\n    }\n\n\n    function reinterpretAsDestructuredParameter(options, expr) {\n        var i, len, property, element;\n\n        if (expr.type === Syntax.ObjectExpression) {\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0, len = expr.properties.length; i < len; i += 1) {\n                property = expr.properties[i];\n                if (property.type === Syntax.SpreadProperty) {\n                    if (i < len - 1) {\n                        throwError({}, Messages.PropertyAfterSpreadProperty);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.argument);\n                } else {\n                    if (property.kind !== 'init') {\n                        throwError({}, Messages.InvalidLHSInFormalsList);\n                    }\n                    reinterpretAsDestructuredParameter(options, property.value);\n                }\n            }\n        } else if (expr.type === Syntax.ArrayExpression) {\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0, len = expr.elements.length; i < len; i += 1) {\n                element = expr.elements[i];\n                if (element) {\n                    reinterpretAsDestructuredParameter(options, element);\n                }\n            }\n        } else if (expr.type === Syntax.Identifier) {\n            validateParam(options, expr, expr.name);\n        } else {\n            if (expr.type !== Syntax.MemberExpression) {\n                throwError({}, Messages.InvalidLHSInFormalsList);\n            }\n        }\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {\n                reinterpretAsDestructuredParameter(options, param);\n                params.push(param);\n                defaults.push(null);\n            } else if (param.type === Syntax.SpreadElement) {\n                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');\n                reinterpretAsDestructuredParameter(options, param.argument);\n                rest = param.argument;\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            throwError(\n                strict ? options.stricted : options.firstRestricted,\n                options.message\n            );\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, marker) {\n        var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;\n\n        expect('=>');\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = false;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = !!options.async;\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwError(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            throwErrorTolerant(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(marker, delegate.createArrowFunctionExpression(\n            options.params,\n            options.defaults,\n            body,\n            options.rest,\n            body.type !== Syntax.BlockStatement,\n            !!options.async\n        ));\n    }\n\n    function parseAssignmentExpression() {\n        var marker, expr, token, params, oldParenthesizedCount,\n            backtrackToken = lookahead, possiblyAsync = false;\n\n        if (matchYield()) {\n            return parseYieldExpression();\n        }\n\n        if (matchAwait()) {\n            return parseAwaitExpression();\n        }\n\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        marker = markerCreate();\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionExpression();\n        }\n\n        if (matchAsync()) {\n            // We can't be completely sure that this 'async' token is\n            // actually a contextual keyword modifying a function\n            // expression, so we might have to un-lex() it later by\n            // calling rewind(backtrackToken).\n            possiblyAsync = true;\n            lex();\n        }\n\n        if (match('(')) {\n            token = lookahead2();\n            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {\n                params = parseParams();\n                if (!match('=>')) {\n                    throwUnexpected(lex());\n                }\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n\n        token = lookahead;\n\n        // If the 'async' keyword is not followed by a '(' character or an\n        // identifier, then it can't be an arrow function modifier, and we\n        // should interpret it as a normal identifer.\n        if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n        }\n\n        expr = parseConditionalExpression();\n\n        if (match('=>') &&\n                (state.parenthesizedCount === oldParenthesizedCount ||\n                state.parenthesizedCount === (oldParenthesizedCount + 1))) {\n            if (expr.type === Syntax.Identifier) {\n                params = reinterpretAsCoverFormalsList([ expr ]);\n            } else if (expr.type === Syntax.SequenceExpression) {\n                params = reinterpretAsCoverFormalsList(expr.expressions);\n            }\n            if (params) {\n                params.async = possiblyAsync;\n                return parseArrowFunctionExpression(params, marker);\n            }\n        }\n\n        // If we haven't returned by now, then the 'async' keyword was not\n        // a function modifier, and we should rewind and interpret it as a\n        // normal identifier.\n        if (possiblyAsync) {\n            possiblyAsync = false;\n            rewind(backtrackToken);\n            expr = parseConditionalExpression();\n        }\n\n        if (matchAssign()) {\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            // ES.next draf 11.13 Runtime Semantics step 1\n            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {\n                reinterpretAsAssignmentBindingPattern(expr);\n            } else if (!isLeftHandSide(expr)) {\n                throwError({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var marker, expr, expressions, sequence, coverFormalsList, spreadFound, oldParenthesizedCount;\n\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        marker = markerCreate();\n        expr = parseAssignmentExpression();\n        expressions = [ expr ];\n\n        if (match(',')) {\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n\n                lex();\n                expr = parseSpreadOrAssignmentExpression();\n                expressions.push(expr);\n\n                if (expr.type === Syntax.SpreadElement) {\n                    spreadFound = true;\n                    if (!match(')')) {\n                        throwError({}, Messages.ElementAfterSpreadElement);\n                    }\n                    break;\n                }\n            }\n\n            sequence = markerApply(marker, delegate.createSequenceExpression(expressions));\n        }\n\n        if (match('=>')) {\n            // Do not allow nested parentheses on the LHS of the =>.\n            if (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === (oldParenthesizedCount + 1)) {\n                expr = expr.type === Syntax.SequenceExpression ? expr.expressions : expressions;\n                coverFormalsList = reinterpretAsCoverFormalsList(expr);\n                if (coverFormalsList) {\n                    return parseArrowFunctionExpression(coverFormalsList, marker);\n                }\n            }\n            throwUnexpected(lex());\n        }\n\n        if (spreadFound && lookahead2().value !== '=>') {\n            throwError({}, Messages.IllegalSpread);\n        }\n\n        return sequence || expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, marker = markerCreate();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return markerApply(marker, delegate.createBlockStatement(block));\n    }\n\n    // 12.2 Variable Statement\n\n    function parseTypeParameterDeclaration() {\n        var marker = markerCreate(), paramTypes = [];\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseVariableIdentifier());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        return markerApply(marker, delegate.createTypeParameterDeclaration(\n            paramTypes\n        ));\n    }\n\n    function parseTypeParameterInstantiation() {\n        var marker = markerCreate(), oldInType = state.inType, paramTypes = [];\n\n        state.inType = true;\n\n        expect('<');\n        while (!match('>')) {\n            paramTypes.push(parseType());\n            if (!match('>')) {\n                expect(',');\n            }\n        }\n        expect('>');\n\n        state.inType = oldInType;\n\n        return markerApply(marker, delegate.createTypeParameterInstantiation(\n            paramTypes\n        ));\n    }\n\n    function parseObjectTypeIndexer(marker, isStatic) {\n        var id, key, value;\n\n        expect('[');\n        id = parseObjectPropertyKey();\n        expect(':');\n        key = parseType();\n        expect(']');\n        expect(':');\n        value = parseType();\n\n        return markerApply(marker, delegate.createObjectTypeIndexer(\n            id,\n            key,\n            value,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeMethodish(marker) {\n        var params = [], rest = null, returnType, typeParameters = null;\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        expect('(');\n        while (lookahead.type === Token.Identifier) {\n            params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            rest = parseFunctionTypeParam();\n        }\n        expect(')');\n        expect(':');\n        returnType = parseType();\n\n        return markerApply(marker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n    }\n\n    function parseObjectTypeMethod(marker, isStatic, key) {\n        var optional = false, value;\n        value = parseObjectTypeMethodish(marker);\n\n        return markerApply(marker, delegate.createObjectTypeProperty(\n            key,\n            value,\n            optional,\n            isStatic\n        ));\n    }\n\n    function parseObjectTypeCallProperty(marker, isStatic) {\n        var valueMarker = markerCreate();\n        return markerApply(marker, delegate.createObjectTypeCallProperty(\n            parseObjectTypeMethodish(valueMarker),\n            isStatic\n        ));\n    }\n\n    function parseObjectType(allowStatic) {\n        var callProperties = [], indexers = [], marker, optional = false,\n            properties = [], property, propertyKey, propertyTypeAnnotation,\n            token, isStatic;\n\n        expect('{');\n\n        while (!match('}')) {\n            marker = markerCreate();\n            if (allowStatic && matchContextualKeyword('static')) {\n                token = lex();\n                isStatic = true;\n            }\n\n            if (match('[')) {\n                indexers.push(parseObjectTypeIndexer(marker, isStatic));\n            } else if (match('(') || match('<')) {\n                callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));\n            } else {\n                if (isStatic && match(':')) {\n                    propertyKey = markerApply(marker, delegate.createIdentifier(token));\n                    throwErrorTolerant(token, Messages.StrictReservedWord);\n                } else {\n                    propertyKey = parseObjectPropertyKey();\n                }\n                if (match('<') || match('(')) {\n                    // This is a method property\n                    properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));\n                } else {\n                    if (match('?')) {\n                        lex();\n                        optional = true;\n                    }\n                    expect(':');\n                    propertyTypeAnnotation = parseType();\n                    properties.push(markerApply(marker, delegate.createObjectTypeProperty(\n                        propertyKey,\n                        propertyTypeAnnotation,\n                        optional,\n                        isStatic\n                    )));\n                }\n            }\n\n            if (match(';')) {\n                lex();\n            } else if (!match('}')) {\n                throwUnexpected(lookahead);\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectTypeAnnotation(\n            properties,\n            indexers,\n            callProperties\n        );\n    }\n\n    function parseGenericType() {\n        var marker = markerCreate(), returnType = null,\n            typeParameters = null, typeIdentifier,\n            typeIdentifierMarker = markerCreate;\n\n        typeIdentifier = parseVariableIdentifier();\n\n        while (match('.')) {\n            expect('.');\n            typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(\n                typeIdentifier,\n                parseVariableIdentifier()\n            ));\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createGenericTypeAnnotation(\n            typeIdentifier,\n            typeParameters\n        ));\n    }\n\n    function parseVoidType() {\n        var marker = markerCreate();\n        expectKeyword('void');\n        return markerApply(marker, delegate.createVoidTypeAnnotation());\n    }\n\n    function parseTypeofType() {\n        var argument, marker = markerCreate();\n        expectKeyword('typeof');\n        argument = parsePrimaryType();\n        return markerApply(marker, delegate.createTypeofTypeAnnotation(\n            argument\n        ));\n    }\n\n    function parseTupleType() {\n        var marker = markerCreate(), types = [];\n        expect('[');\n        // We allow trailing commas\n        while (index < length && !match(']')) {\n            types.push(parseType());\n            if (match(']')) {\n                break;\n            }\n            expect(',');\n        }\n        expect(']');\n        return markerApply(marker, delegate.createTupleTypeAnnotation(\n            types\n        ));\n    }\n\n    function parseFunctionTypeParam() {\n        var marker = markerCreate(), name, optional = false, typeAnnotation;\n        name = parseVariableIdentifier();\n        if (match('?')) {\n            lex();\n            optional = true;\n        }\n        expect(':');\n        typeAnnotation = parseType();\n        return markerApply(marker, delegate.createFunctionTypeParam(\n            name,\n            typeAnnotation,\n            optional\n        ));\n    }\n\n    function parseFunctionTypeParams() {\n        var ret = { params: [], rest: null };\n        while (lookahead.type === Token.Identifier) {\n            ret.params.push(parseFunctionTypeParam());\n            if (!match(')')) {\n                expect(',');\n            }\n        }\n\n        if (match('...')) {\n            lex();\n            ret.rest = parseFunctionTypeParam();\n        }\n        return ret;\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    function parsePrimaryType() {\n        var typeIdentifier = null, params = null, returnType = null,\n            marker = markerCreate(), rest = null, tmp,\n            typeParameters, token, type, isGroupedType = false;\n\n        switch (lookahead.type) {\n        case Token.Identifier:\n            switch (lookahead.value) {\n            case 'any':\n                lex();\n                return markerApply(marker, delegate.createAnyTypeAnnotation());\n            case 'bool':  // fallthrough\n            case 'boolean':\n                lex();\n                return markerApply(marker, delegate.createBooleanTypeAnnotation());\n            case 'number':\n                lex();\n                return markerApply(marker, delegate.createNumberTypeAnnotation());\n            case 'string':\n                lex();\n                return markerApply(marker, delegate.createStringTypeAnnotation());\n            }\n            return markerApply(marker, parseGenericType());\n        case Token.Punctuator:\n            switch (lookahead.value) {\n            case '{':\n                return markerApply(marker, parseObjectType());\n            case '[':\n                return parseTupleType();\n            case '<':\n                typeParameters = parseTypeParameterDeclaration();\n                expect('(');\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    typeParameters\n                ));\n            case '(':\n                lex();\n                // Check to see if this is actually a grouped type\n                if (!match(')') && !match('...')) {\n                    if (lookahead.type === Token.Identifier) {\n                        token = lookahead2();\n                        isGroupedType = token.value !== '?' && token.value !== ':';\n                    } else {\n                        isGroupedType = true;\n                    }\n                }\n\n                if (isGroupedType) {\n                    type = parseType();\n                    expect(')');\n\n                    // If we see a => next then someone was probably confused about\n                    // function types, so we can provide a better error message\n                    if (match('=>')) {\n                        throwError({}, Messages.ConfusedAboutFunctionType);\n                    }\n\n                    return type;\n                }\n\n                tmp = parseFunctionTypeParams();\n                params = tmp.params;\n                rest = tmp.rest;\n\n                expect(')');\n\n                expect('=>');\n\n                returnType = parseType();\n\n                return markerApply(marker, delegate.createFunctionTypeAnnotation(\n                    params,\n                    returnType,\n                    rest,\n                    null /* typeParameters */\n                ));\n            }\n            break;\n        case Token.Keyword:\n            switch (lookahead.value) {\n            case 'void':\n                return markerApply(marker, parseVoidType());\n            case 'typeof':\n                return markerApply(marker, parseTypeofType());\n            }\n            break;\n        case Token.StringLiteral:\n            token = lex();\n            if (token.octal) {\n                throwError(token, Messages.StrictOctalLiteral);\n            }\n            return markerApply(marker, delegate.createStringLiteralTypeAnnotation(\n                token\n            ));\n        }\n\n        throwUnexpected(lookahead);\n    }\n\n    function parsePostfixType() {\n        var marker = markerCreate(), t = parsePrimaryType();\n        if (match('[')) {\n            expect('[');\n            expect(']');\n            return markerApply(marker, delegate.createArrayTypeAnnotation(t));\n        }\n        return t;\n    }\n\n    function parsePrefixType() {\n        var marker = markerCreate();\n        if (match('?')) {\n            lex();\n            return markerApply(marker, delegate.createNullableTypeAnnotation(\n                parsePrefixType()\n            ));\n        }\n        return parsePostfixType();\n    }\n\n\n    function parseIntersectionType() {\n        var marker = markerCreate(), type, types;\n        type = parsePrefixType();\n        types = [type];\n        while (match('&')) {\n            lex();\n            types.push(parsePrefixType());\n        }\n\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createIntersectionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseUnionType() {\n        var marker = markerCreate(), type, types;\n        type = parseIntersectionType();\n        types = [type];\n        while (match('|')) {\n            lex();\n            types.push(parseIntersectionType());\n        }\n        return types.length === 1 ?\n                type :\n                markerApply(marker, delegate.createUnionTypeAnnotation(\n                    types\n                ));\n    }\n\n    function parseType() {\n        var oldInType = state.inType, type;\n        state.inType = true;\n\n        type = parseUnionType();\n\n        state.inType = oldInType;\n        return type;\n    }\n\n    function parseTypeAnnotation() {\n        var marker = markerCreate(), type;\n\n        expect(':');\n        type = parseType();\n\n        return markerApply(marker, delegate.createTypeAnnotation(type));\n    }\n\n    function parseVariableIdentifier() {\n        var marker = markerCreate(),\n            token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return markerApply(marker, delegate.createIdentifier(token.value));\n    }\n\n    function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {\n        var marker = markerCreate(),\n            ident = parseVariableIdentifier(),\n            isOptionalParam = false;\n\n        if (canBeOptionalParam && match('?')) {\n            expect('?');\n            isOptionalParam = true;\n        }\n\n        if (requireTypeAnnotation || match(':')) {\n            ident.typeAnnotation = parseTypeAnnotation();\n            ident = markerApply(marker, ident);\n        }\n\n        if (isOptionalParam) {\n            ident.optional = true;\n            ident = markerApply(marker, ident);\n        }\n\n        return ident;\n    }\n\n    function parseVariableDeclaration(kind) {\n        var id,\n            marker = markerCreate(),\n            init = null,\n            typeAnnotationMarker = markerCreate();\n        if (match('{')) {\n            id = parseObjectInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else if (match('[')) {\n            id = parseArrayInitialiser();\n            reinterpretAsAssignmentBindingPattern(id);\n            if (match(':')) {\n                id.typeAnnotation = parseTypeAnnotation();\n                markerApply(typeAnnotationMarker, id);\n            }\n        } else {\n            id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();\n            // 12.2.1\n            if (strict && isRestrictedWord(id.name)) {\n                throwErrorTolerant({}, Messages.StrictVarName);\n            }\n        }\n\n        if (kind === 'const') {\n            if (!match('=')) {\n                throwError({}, Messages.NoUnintializedConst);\n            }\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return markerApply(marker, delegate.createVariableDeclarator(id, init));\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations, marker = markerCreate();\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, marker = markerCreate();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));\n    }\n\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var marker = markerCreate(),\n            specifier;\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError({}, Messages.InvalidModuleSpecifier);\n        }\n        specifier = delegate.createModuleSpecifier(lookahead);\n        lex();\n        return markerApply(marker, specifier);\n    }\n\n    function parseExportBatchSpecifier() {\n        var marker = markerCreate();\n        expect('*');\n        return markerApply(marker, delegate.createExportBatchSpecifier());\n    }\n\n    function parseExportSpecifier() {\n        var id, name = null, marker = markerCreate(), from;\n        if (matchKeyword('default')) {\n            lex();\n            id = markerApply(marker, delegate.createIdentifier('default'));\n            // export {default} from \"something\";\n        } else {\n            id = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseNonComputedProperty();\n        }\n\n        return markerApply(marker, delegate.createExportSpecifier(id, name));\n    }\n\n    function parseExportDeclaration() {\n        var backtrackToken, id, previousAllowKeyword, declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [],\n            marker = markerCreate();\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            // covers:\n            // export default ...\n            lex();\n            if (matchKeyword('function') || matchKeyword('class')) {\n                backtrackToken = lookahead;\n                lex();\n                if (isIdentifierName(lookahead)) {\n                    // covers:\n                    // export default function foo () {}\n                    // export default class foo {}\n                    id = parseNonComputedProperty();\n                    rewind(backtrackToken);\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseSourceElement(), [id], null));\n                }\n                // covers:\n                // export default function () {}\n                // export default class {}\n                rewind(backtrackToken);\n                switch (lookahead.value) {\n                case 'class':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));\n                case 'function':\n                    return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));\n                }\n            }\n\n            if (matchContextualKeyword('from')) {\n                throwError({}, Messages.UnexpectedToken, lookahead.value);\n            }\n\n            // covers:\n            // export default {};\n            // export default [];\n            if (match('{')) {\n                declaration = parseObjectInitialiser();\n            } else if (match('[')) {\n                declaration = parseArrayInitialiser();\n            } else {\n                declaration = parseAssignmentExpression();\n            }\n            consumeSemicolon();\n            return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));\n        }\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n            case 'let':\n            case 'const':\n            case 'var':\n            case 'class':\n            case 'function':\n                return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));\n            }\n        }\n\n        if (match('*')) {\n            // covers:\n            // export * from \"foo\";\n            specifiers.push(parseExportBatchSpecifier());\n\n            if (!matchContextualKeyword('from')) {\n                throwError({}, lookahead.value ?\n                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n            }\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n\n            return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));\n        }\n\n        expect('{');\n        do {\n            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n            specifiers.push(parseExportSpecifier());\n        } while (match(',') && lex());\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from \"foo\";\n            // export {foo} from \"foo\";\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));\n    }\n\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var id, name = null, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            name = parseVariableIdentifier();\n        }\n\n        return markerApply(marker, delegate.createImportSpecifier(id, name));\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        do {\n            specifiers.push(parseImportSpecifier());\n        } while (match(',') && lex());\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var id, marker = markerCreate();\n\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportDefaultSpecifier(id));\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var id, marker = markerCreate();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError({}, Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        id = parseNonComputedProperty();\n\n        return markerApply(marker, delegate.createImportNamespaceSpecifier(id));\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, marker = markerCreate();\n\n        expectKeyword('import');\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import \"foo\";\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return markerApply(marker, delegate.createImportDeclaration(specifiers, src));\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError({}, lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createImportDeclaration(specifiers, src));\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        var marker = markerCreate();\n        expect(';');\n        return markerApply(marker, delegate.createEmptyStatement());\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var marker = markerCreate(), expr = parseExpression();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate, marker = markerCreate();\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration, marker = markerCreate();\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return markerApply(marker, delegate.createDoWhileStatement(body, test));\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration, marker = markerCreate();\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return markerApply(marker, delegate.createWhileStatement(test, body));\n    }\n\n    function parseForVariableDeclaration() {\n        var marker = markerCreate(),\n            token = lex(),\n            declarations = parseVariableDeclarationList();\n\n        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));\n    }\n\n    function parseForStatement(opts) {\n        var init, test, update, left, right, body, operator, oldInIteration,\n            marker = markerCreate();\n        init = test = update = null;\n        expectKeyword('for');\n\n        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each\n        if (matchContextualKeyword('each')) {\n            throwError({}, Messages.EachNotAllowed);\n        }\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = true;\n\n                if (init.declarations.length === 1) {\n                    if (matchKeyword('in') || matchContextualKeyword('of')) {\n                        operator = lookahead;\n                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {\n                            lex();\n                            left = init;\n                            right = parseExpression();\n                            init = null;\n                        }\n                    }\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = true;\n\n                if (matchContextualKeyword('of')) {\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isAssignableLeftHandSide(init)) {\n                        throwError({}, Messages.InvalidLHSInForIn);\n                    }\n                    operator = lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        if (!(opts !== undefined && opts.ignoreBody)) {\n            body = parseStatement();\n        }\n\n        state.inIteration = oldInIteration;\n\n        if (typeof left === 'undefined') {\n            return markerApply(marker, delegate.createForStatement(init, test, update, body));\n        }\n\n        if (operator.value === 'in') {\n            return markerApply(marker, delegate.createForInStatement(left, right, body));\n        }\n        return markerApply(marker, delegate.createForOfStatement(left, right, body));\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key, marker = markerCreate();\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return markerApply(marker, delegate.createContinueStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return markerApply(marker, delegate.createContinueStatement(label));\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key, marker = markerCreate();\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return markerApply(marker, delegate.createBreakStatement(null));\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return markerApply(marker, delegate.createBreakStatement(label));\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null, marker = markerCreate();\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 32) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return markerApply(marker, delegate.createReturnStatement(argument));\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return markerApply(marker, delegate.createReturnStatement(null));\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createReturnStatement(argument));\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body, marker = markerCreate();\n\n        if (strict) {\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return markerApply(marker, delegate.createWithStatement(object, body));\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test,\n            consequent = [],\n            sourceElement,\n            marker = markerCreate();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            consequent.push(sourceElement);\n        }\n\n        return markerApply(marker, delegate.createSwitchCase(test, consequent));\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument, marker = markerCreate();\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createThrowStatement(argument));\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, marker = markerCreate();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseExpression();\n        // 12.14.1\n        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return markerApply(marker, delegate.createCatchClause(param, body));\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null, marker = markerCreate();\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        var marker = markerCreate();\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDebuggerStatement());\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            marker,\n            expr,\n            labeledBody,\n            key;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement();\n            case '{':\n                return parseBlock();\n            case '(':\n                return parseExpressionStatement();\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement();\n            case 'continue':\n                return parseContinueStatement();\n            case 'debugger':\n                return parseDebuggerStatement();\n            case 'do':\n                return parseDoWhileStatement();\n            case 'for':\n                return parseForStatement();\n            case 'function':\n                return parseFunctionDeclaration();\n            case 'class':\n                return parseClassDeclaration();\n            case 'if':\n                return parseIfStatement();\n            case 'return':\n                return parseReturnStatement();\n            case 'switch':\n                return parseSwitchStatement();\n            case 'throw':\n                return parseThrowStatement();\n            case 'try':\n                return parseTryStatement();\n            case 'var':\n                return parseVariableStatement();\n            case 'while':\n                return parseWhileStatement();\n            case 'with':\n                return parseWithStatement();\n            default:\n                break;\n            }\n        }\n\n        if (matchAsyncFuncExprOrDecl()) {\n            return parseFunctionDeclaration();\n        }\n\n        marker = markerCreate();\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));\n        }\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createExpressionStatement(expr));\n    }\n\n    // 13 Function Definition\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,\n            marker = markerCreate();\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesizedCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesizedCount;\n\n        return markerApply(marker, delegate.createBlockStatement(sourceElements));\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var marker, token, rest, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            token = lex();\n            rest = true;\n        }\n\n        if (match('[')) {\n            marker = markerCreate();\n            param = parseArrayInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else if (match('{')) {\n            marker = markerCreate();\n            if (rest) {\n                throwError({}, Messages.ObjectPatternAsRestParameter);\n            }\n            param = parseObjectInitialiser();\n            reinterpretAsDestructuredParameter(options, param);\n            if (match(':')) {\n                param.typeAnnotation = parseTypeAnnotation();\n                markerApply(marker, param);\n            }\n        } else {\n            param =\n                rest\n                ? parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    false /* canBeOptionalParam */\n                )\n                : parseTypeAnnotatableIdentifier(\n                    false, /* requireTypeAnnotation */\n                    true /* canBeOptionalParam */\n                );\n\n            validateParam(options, token, token.value);\n        }\n\n        if (match('=')) {\n            if (rest) {\n                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);\n            }\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n\n        if (rest) {\n            if (!match(')')) {\n                throwError({}, Messages.ParameterAfterRestParameter);\n            }\n            options.rest = param;\n            return false;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options, marker = markerCreate();\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            rest: null,\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        if (match(':')) {\n            options.returnType = parseTypeAnnotation();\n        }\n\n        return markerApply(marker, options);\n    }\n\n    function parseFunctionDeclaration() {\n        var id, body, token, tmp, firstRestricted, message, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        token = lookahead;\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionDeclaration(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,\n            previousStrict, previousYieldAllowed, previousAwaitAllowed,\n            marker = markerCreate(), typeParameters;\n\n        isAsync = false;\n        if (matchAsync()) {\n            lex();\n            isAsync = true;\n        }\n\n        expectKeyword('function');\n\n        generator = false;\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        if (!match('(')) {\n            if (!match('<')) {\n                token = lookahead;\n                id = parseVariableIdentifier();\n\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        throwErrorTolerant(token, Messages.StrictFunctionName);\n                    }\n                } else {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictFunctionName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            if (match('<')) {\n                typeParameters = parseTypeParameterDeclaration();\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        previousYieldAllowed = state.yieldAllowed;\n        state.yieldAllowed = generator;\n        previousAwaitAllowed = state.awaitAllowed;\n        state.awaitAllowed = isAsync;\n\n        body = parseFunctionSourceElements();\n\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && tmp.stricted) {\n            throwErrorTolerant(tmp.stricted, message);\n        }\n        strict = previousStrict;\n        state.yieldAllowed = previousYieldAllowed;\n        state.awaitAllowed = previousAwaitAllowed;\n\n        return markerApply(\n            marker,\n            delegate.createFunctionExpression(\n                id,\n                tmp.params,\n                tmp.defaults,\n                body,\n                tmp.rest,\n                generator,\n                false,\n                isAsync,\n                tmp.returnType,\n                typeParameters\n            )\n        );\n    }\n\n    function parseYieldExpression() {\n        var delegateFlag, expr, marker = markerCreate();\n\n        expectKeyword('yield', !strict);\n\n        delegateFlag = false;\n        if (match('*')) {\n            lex();\n            delegateFlag = true;\n        }\n\n        expr = parseAssignmentExpression();\n\n        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));\n    }\n\n    function parseAwaitExpression() {\n        var expr, marker = markerCreate();\n        expectContextualKeyword('await');\n        expr = parseAssignmentExpression();\n        return markerApply(marker, delegate.createAwaitExpression(expr));\n    }\n\n    // 14 Classes\n\n    function parseMethodDefinition(existingPropNames, key, isStatic, generator, computed) {\n        var token, param, propType, isValidDuplicateProp = false,\n            isAsync, typeParameters, tokenValue, returnType,\n            annotationMarker;\n\n        propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;\n\n        if (generator) {\n            return delegate.createMethodDefinition(\n                propType,\n                '',\n                key,\n                parsePropertyMethodFunction({ generator: true })\n            );\n        }\n\n        tokenValue = key.type === 'Identifier' && key.name;\n\n        if (tokenValue === 'get' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            // It is a syntax error if any other properties have a name\n            // duplicating this one unless they are a setter\n            if (existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp =\n                    // There isn't already a getter for this prop\n                    existingPropNames[propType][key.name].get === undefined\n                    // There isn't already a data prop by this name\n                    && existingPropNames[propType][key.name].data === undefined\n                    // The only existing prop by this name is a setter\n                    && existingPropNames[propType][key.name].set !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].get = true;\n\n            expect('(');\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'get',\n                key,\n                parsePropertyFunction({ generator: false, returnType: returnType })\n            );\n        }\n        if (tokenValue === 'set' && !match('(')) {\n            key = parseObjectPropertyKey();\n\n            // It is a syntax error if any other properties have a name\n            // duplicating this one unless they are a getter\n            if (existingPropNames[propType].hasOwnProperty(key.name)) {\n                isValidDuplicateProp =\n                    // There isn't already a setter for this prop\n                    existingPropNames[propType][key.name].set === undefined\n                    // There isn't already a data prop by this name\n                    && existingPropNames[propType][key.name].data === undefined\n                    // The only existing prop by this name is a getter\n                    && existingPropNames[propType][key.name].get !== undefined;\n                if (!isValidDuplicateProp) {\n                    throwError(key, Messages.IllegalDuplicateClassProperty);\n                }\n            } else {\n                existingPropNames[propType][key.name] = {};\n            }\n            existingPropNames[propType][key.name].set = true;\n\n            expect('(');\n            token = lookahead;\n            param = [ parseTypeAnnotatableIdentifier() ];\n            expect(')');\n            if (match(':')) {\n                returnType = parseTypeAnnotation();\n            }\n            return delegate.createMethodDefinition(\n                propType,\n                'set',\n                key,\n                parsePropertyFunction({\n                    params: param,\n                    generator: false,\n                    name: token,\n                    returnType: returnType\n                })\n            );\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        isAsync = tokenValue === 'async' && !match('(');\n        if (isAsync) {\n            key = parseObjectPropertyKey();\n        }\n\n        // It is a syntax error if any other properties have the same name as a\n        // non-getter, non-setter method\n        if (existingPropNames[propType].hasOwnProperty(key.name)) {\n            throwError(key, Messages.IllegalDuplicateClassProperty);\n        } else {\n            existingPropNames[propType][key.name] = {};\n        }\n        existingPropNames[propType][key.name].data = true;\n\n        return delegate.createMethodDefinition(\n            propType,\n            '',\n            key,\n            parsePropertyMethodFunction({\n                generator: false,\n                async: isAsync,\n                typeParameters: typeParameters\n            })\n        );\n    }\n\n    function parseClassProperty(existingPropNames, key, computed, isStatic) {\n        var typeAnnotation;\n\n        typeAnnotation = parseTypeAnnotation();\n        expect(';');\n\n        return delegate.createClassProperty(\n            key,\n            typeAnnotation,\n            computed,\n            isStatic\n        );\n    }\n\n    function parseClassElement(existingProps) {\n        var computed, generator = false, key, marker = markerCreate(),\n            isStatic = false;\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.value === 'static') {\n            lex();\n            isStatic = true;\n        }\n\n        if (match('*')) {\n            lex();\n            generator = true;\n        }\n\n        computed = (lookahead.value === '[');\n        key = parseObjectPropertyKey();\n\n        if (!generator && lookahead.value === ':') {\n            return markerApply(marker, parseClassProperty(existingProps, key, computed, isStatic));\n        }\n\n        return markerApply(marker, parseMethodDefinition(\n            existingProps,\n            key,\n            isStatic,\n            generator,\n            computed\n        ));\n    }\n\n    function parseClassBody() {\n        var classElement, classElements = [], existingProps = {}, marker = markerCreate();\n\n        existingProps[ClassPropertyType.static] = {};\n        existingProps[ClassPropertyType.prototype] = {};\n\n        expect('{');\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            classElement = parseClassElement(existingProps);\n\n            if (typeof classElement !== 'undefined') {\n                classElements.push(classElement);\n            }\n        }\n\n        expect('}');\n\n        return markerApply(marker, delegate.createClassBody(classElements));\n    }\n\n    function parseClassImplements() {\n        var id, implemented = [], marker, typeParameters;\n        expectContextualKeyword('implements');\n        while (index < length) {\n            marker = markerCreate();\n            id = parseVariableIdentifier();\n            if (match('<')) {\n                typeParameters = parseTypeParameterInstantiation();\n            } else {\n                typeParameters = null;\n            }\n            implemented.push(markerApply(marker, delegate.createClassImplements(\n                id,\n                typeParameters\n            )));\n            if (!match(',')) {\n                break;\n            }\n            expect(',');\n        }\n        return implemented;\n    }\n\n    function parseClassExpression() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters;\n\n        expectKeyword('class');\n\n        if (!matchKeyword('extends') && !matchContextualKeyword('implements') && !match('{')) {\n            id = parseVariableIdentifier();\n        }\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassExpression(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    function parseClassDeclaration() {\n        var id, implemented, previousYieldAllowed, superClass = null,\n            superTypeParameters, marker = markerCreate(), typeParameters;\n\n        expectKeyword('class');\n\n        id = parseVariableIdentifier();\n\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n            previousYieldAllowed = state.yieldAllowed;\n            state.yieldAllowed = false;\n            superClass = parseLeftHandSideExpressionAllowCall();\n            if (match('<')) {\n                superTypeParameters = parseTypeParameterInstantiation();\n            }\n            state.yieldAllowed = previousYieldAllowed;\n        }\n\n        if (matchContextualKeyword('implements')) {\n            implemented = parseClassImplements();\n        }\n\n        return markerApply(marker, delegate.createClassDeclaration(\n            id,\n            superClass,\n            parseClassBody(),\n            typeParameters,\n            superTypeParameters,\n            implemented\n        ));\n    }\n\n    // 15 Program\n\n    function parseSourceElement() {\n        var token;\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (matchContextualKeyword('type')\n                && lookahead2().type === Token.Identifier) {\n            return parseTypeAlias();\n        }\n\n        if (matchContextualKeyword('interface')\n                && lookahead2().type === Token.Identifier) {\n            return parseInterface();\n        }\n\n        if (matchContextualKeyword('declare')) {\n            token = lookahead2();\n            if (token.type === Token.Keyword) {\n                switch (token.value) {\n                case 'class':\n                    return parseDeclareClass();\n                case 'function':\n                    return parseDeclareFunction();\n                case 'var':\n                    return parseDeclareVariable();\n                }\n            } else if (token.type === Token.Identifier\n                    && token.value === 'module') {\n                return parseDeclareModule();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseProgramElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                return parseExportDeclaration();\n            case 'import':\n                return parseImportDeclaration();\n            }\n        }\n\n        return parseSourceElement();\n    }\n\n    function parseProgramElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseProgramElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.range[0] + 1, token.range[1] - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseProgramElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, marker = markerCreate();\n        strict = false;\n        peek();\n        body = parseProgramElements();\n        return markerApply(marker, delegate.createProgram(body));\n    }\n\n    // The following functions are needed only when the option to preserve\n    // the comments is active.\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function scanComment() {\n        var comment, ch, loc, start, blockComment, lineComment;\n\n        comment = '';\n        blockComment = false;\n        lineComment = false;\n\n        while (index < length) {\n            ch = source[index];\n\n            if (lineComment) {\n                ch = source[index++];\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    lineComment = false;\n                    addComment('Line', comment, start, index - 1, loc);\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    ++lineNumber;\n                    lineStart = index;\n                    comment = '';\n                } else if (index >= length) {\n                    lineComment = false;\n                    comment += ch;\n                    loc.end = {\n                        line: lineNumber,\n                        column: length - lineStart\n                    };\n                    addComment('Line', comment, start, length, loc);\n                } else {\n                    comment += ch;\n                }\n            } else if (blockComment) {\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    if (ch === '\\r') {\n                        ++index;\n                        comment += '\\r';\n                    }\n                    if (ch !== '\\r' || source[index] === '\\n') {\n                        comment += source[index];\n                        ++lineNumber;\n                        ++index;\n                        lineStart = index;\n                        if (index >= length) {\n                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                        }\n                    }\n                } else {\n                    ch = source[index++];\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                    comment += ch;\n                    if (ch === '*') {\n                        ch = source[index];\n                        if (ch === '/') {\n                            comment = comment.substr(0, comment.length - 1);\n                            blockComment = false;\n                            ++index;\n                            loc.end = {\n                                line: lineNumber,\n                                column: index - lineStart\n                            };\n                            addComment('Block', comment, start, index, loc);\n                            comment = '';\n                        }\n                    }\n                }\n            } else if (ch === '/') {\n                ch = source[index + 1];\n                if (ch === '/') {\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart\n                        }\n                    };\n                    start = index;\n                    index += 2;\n                    lineComment = true;\n                    if (index >= length) {\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        lineComment = false;\n                        addComment('Line', comment, start, index, loc);\n                    }\n                } else if (ch === '*') {\n                    start = index;\n                    index += 2;\n                    blockComment = true;\n                    loc = {\n                        start: {\n                            line: lineNumber,\n                            column: index - lineStart - 2\n                        }\n                    };\n                    if (index >= length) {\n                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                    }\n                } else {\n                    break;\n                }\n            } else if (isWhiteSpace(ch.charCodeAt(0))) {\n                ++index;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++index;\n                if (ch ===  '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // 16 XJS\n\n    XHTMLEntities = {\n        quot: '\\u0022',\n        amp: '&',\n        apos: '\\u0027',\n        lt: '<',\n        gt: '>',\n        nbsp: '\\u00A0',\n        iexcl: '\\u00A1',\n        cent: '\\u00A2',\n        pound: '\\u00A3',\n        curren: '\\u00A4',\n        yen: '\\u00A5',\n        brvbar: '\\u00A6',\n        sect: '\\u00A7',\n        uml: '\\u00A8',\n        copy: '\\u00A9',\n        ordf: '\\u00AA',\n        laquo: '\\u00AB',\n        not: '\\u00AC',\n        shy: '\\u00AD',\n        reg: '\\u00AE',\n        macr: '\\u00AF',\n        deg: '\\u00B0',\n        plusmn: '\\u00B1',\n        sup2: '\\u00B2',\n        sup3: '\\u00B3',\n        acute: '\\u00B4',\n        micro: '\\u00B5',\n        para: '\\u00B6',\n        middot: '\\u00B7',\n        cedil: '\\u00B8',\n        sup1: '\\u00B9',\n        ordm: '\\u00BA',\n        raquo: '\\u00BB',\n        frac14: '\\u00BC',\n        frac12: '\\u00BD',\n        frac34: '\\u00BE',\n        iquest: '\\u00BF',\n        Agrave: '\\u00C0',\n        Aacute: '\\u00C1',\n        Acirc: '\\u00C2',\n        Atilde: '\\u00C3',\n        Auml: '\\u00C4',\n        Aring: '\\u00C5',\n        AElig: '\\u00C6',\n        Ccedil: '\\u00C7',\n        Egrave: '\\u00C8',\n        Eacute: '\\u00C9',\n        Ecirc: '\\u00CA',\n        Euml: '\\u00CB',\n        Igrave: '\\u00CC',\n        Iacute: '\\u00CD',\n        Icirc: '\\u00CE',\n        Iuml: '\\u00CF',\n        ETH: '\\u00D0',\n        Ntilde: '\\u00D1',\n        Ograve: '\\u00D2',\n        Oacute: '\\u00D3',\n        Ocirc: '\\u00D4',\n        Otilde: '\\u00D5',\n        Ouml: '\\u00D6',\n        times: '\\u00D7',\n        Oslash: '\\u00D8',\n        Ugrave: '\\u00D9',\n        Uacute: '\\u00DA',\n        Ucirc: '\\u00DB',\n        Uuml: '\\u00DC',\n        Yacute: '\\u00DD',\n        THORN: '\\u00DE',\n        szlig: '\\u00DF',\n        agrave: '\\u00E0',\n        aacute: '\\u00E1',\n        acirc: '\\u00E2',\n        atilde: '\\u00E3',\n        auml: '\\u00E4',\n        aring: '\\u00E5',\n        aelig: '\\u00E6',\n        ccedil: '\\u00E7',\n        egrave: '\\u00E8',\n        eacute: '\\u00E9',\n        ecirc: '\\u00EA',\n        euml: '\\u00EB',\n        igrave: '\\u00EC',\n        iacute: '\\u00ED',\n        icirc: '\\u00EE',\n        iuml: '\\u00EF',\n        eth: '\\u00F0',\n        ntilde: '\\u00F1',\n        ograve: '\\u00F2',\n        oacute: '\\u00F3',\n        ocirc: '\\u00F4',\n        otilde: '\\u00F5',\n        ouml: '\\u00F6',\n        divide: '\\u00F7',\n        oslash: '\\u00F8',\n        ugrave: '\\u00F9',\n        uacute: '\\u00FA',\n        ucirc: '\\u00FB',\n        uuml: '\\u00FC',\n        yacute: '\\u00FD',\n        thorn: '\\u00FE',\n        yuml: '\\u00FF',\n        OElig: '\\u0152',\n        oelig: '\\u0153',\n        Scaron: '\\u0160',\n        scaron: '\\u0161',\n        Yuml: '\\u0178',\n        fnof: '\\u0192',\n        circ: '\\u02C6',\n        tilde: '\\u02DC',\n        Alpha: '\\u0391',\n        Beta: '\\u0392',\n        Gamma: '\\u0393',\n        Delta: '\\u0394',\n        Epsilon: '\\u0395',\n        Zeta: '\\u0396',\n        Eta: '\\u0397',\n        Theta: '\\u0398',\n        Iota: '\\u0399',\n        Kappa: '\\u039A',\n        Lambda: '\\u039B',\n        Mu: '\\u039C',\n        Nu: '\\u039D',\n        Xi: '\\u039E',\n        Omicron: '\\u039F',\n        Pi: '\\u03A0',\n        Rho: '\\u03A1',\n        Sigma: '\\u03A3',\n        Tau: '\\u03A4',\n        Upsilon: '\\u03A5',\n        Phi: '\\u03A6',\n        Chi: '\\u03A7',\n        Psi: '\\u03A8',\n        Omega: '\\u03A9',\n        alpha: '\\u03B1',\n        beta: '\\u03B2',\n        gamma: '\\u03B3',\n        delta: '\\u03B4',\n        epsilon: '\\u03B5',\n        zeta: '\\u03B6',\n        eta: '\\u03B7',\n        theta: '\\u03B8',\n        iota: '\\u03B9',\n        kappa: '\\u03BA',\n        lambda: '\\u03BB',\n        mu: '\\u03BC',\n        nu: '\\u03BD',\n        xi: '\\u03BE',\n        omicron: '\\u03BF',\n        pi: '\\u03C0',\n        rho: '\\u03C1',\n        sigmaf: '\\u03C2',\n        sigma: '\\u03C3',\n        tau: '\\u03C4',\n        upsilon: '\\u03C5',\n        phi: '\\u03C6',\n        chi: '\\u03C7',\n        psi: '\\u03C8',\n        omega: '\\u03C9',\n        thetasym: '\\u03D1',\n        upsih: '\\u03D2',\n        piv: '\\u03D6',\n        ensp: '\\u2002',\n        emsp: '\\u2003',\n        thinsp: '\\u2009',\n        zwnj: '\\u200C',\n        zwj: '\\u200D',\n        lrm: '\\u200E',\n        rlm: '\\u200F',\n        ndash: '\\u2013',\n        mdash: '\\u2014',\n        lsquo: '\\u2018',\n        rsquo: '\\u2019',\n        sbquo: '\\u201A',\n        ldquo: '\\u201C',\n        rdquo: '\\u201D',\n        bdquo: '\\u201E',\n        dagger: '\\u2020',\n        Dagger: '\\u2021',\n        bull: '\\u2022',\n        hellip: '\\u2026',\n        permil: '\\u2030',\n        prime: '\\u2032',\n        Prime: '\\u2033',\n        lsaquo: '\\u2039',\n        rsaquo: '\\u203A',\n        oline: '\\u203E',\n        frasl: '\\u2044',\n        euro: '\\u20AC',\n        image: '\\u2111',\n        weierp: '\\u2118',\n        real: '\\u211C',\n        trade: '\\u2122',\n        alefsym: '\\u2135',\n        larr: '\\u2190',\n        uarr: '\\u2191',\n        rarr: '\\u2192',\n        darr: '\\u2193',\n        harr: '\\u2194',\n        crarr: '\\u21B5',\n        lArr: '\\u21D0',\n        uArr: '\\u21D1',\n        rArr: '\\u21D2',\n        dArr: '\\u21D3',\n        hArr: '\\u21D4',\n        forall: '\\u2200',\n        part: '\\u2202',\n        exist: '\\u2203',\n        empty: '\\u2205',\n        nabla: '\\u2207',\n        isin: '\\u2208',\n        notin: '\\u2209',\n        ni: '\\u220B',\n        prod: '\\u220F',\n        sum: '\\u2211',\n        minus: '\\u2212',\n        lowast: '\\u2217',\n        radic: '\\u221A',\n        prop: '\\u221D',\n        infin: '\\u221E',\n        ang: '\\u2220',\n        and: '\\u2227',\n        or: '\\u2228',\n        cap: '\\u2229',\n        cup: '\\u222A',\n        'int': '\\u222B',\n        there4: '\\u2234',\n        sim: '\\u223C',\n        cong: '\\u2245',\n        asymp: '\\u2248',\n        ne: '\\u2260',\n        equiv: '\\u2261',\n        le: '\\u2264',\n        ge: '\\u2265',\n        sub: '\\u2282',\n        sup: '\\u2283',\n        nsub: '\\u2284',\n        sube: '\\u2286',\n        supe: '\\u2287',\n        oplus: '\\u2295',\n        otimes: '\\u2297',\n        perp: '\\u22A5',\n        sdot: '\\u22C5',\n        lceil: '\\u2308',\n        rceil: '\\u2309',\n        lfloor: '\\u230A',\n        rfloor: '\\u230B',\n        lang: '\\u2329',\n        rang: '\\u232A',\n        loz: '\\u25CA',\n        spades: '\\u2660',\n        clubs: '\\u2663',\n        hearts: '\\u2665',\n        diams: '\\u2666'\n    };\n\n    function getQualifiedXJSName(object) {\n        if (object.type === Syntax.XJSIdentifier) {\n            return object.name;\n        }\n        if (object.type === Syntax.XJSNamespacedName) {\n            return object.namespace.name + ':' + object.name.name;\n        }\n        if (object.type === Syntax.XJSMemberExpression) {\n            return (\n                getQualifiedXJSName(object.object) + '.' +\n                getQualifiedXJSName(object.property)\n            );\n        }\n    }\n\n    function isXJSIdentifierStart(ch) {\n        // exclude backslash (\\)\n        return (ch !== 92) && isIdentifierStart(ch);\n    }\n\n    function isXJSIdentifierPart(ch) {\n        // exclude backslash (\\) and add hyphen (-)\n        return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));\n    }\n\n    function scanXJSIdentifier() {\n        var ch, start, value = '';\n\n        start = index;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isXJSIdentifierPart(ch)) {\n                break;\n            }\n            value += source[index++];\n        }\n\n        return {\n            type: Token.XJSIdentifier,\n            value: value,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanXJSEntity() {\n        var ch, str = '', start = index, count = 0, code;\n        ch = source[index];\n        assert(ch === '&', 'Entity must start with an ampersand');\n        index++;\n        while (index < length && count++ < 10) {\n            ch = source[index++];\n            if (ch === ';') {\n                break;\n            }\n            str += ch;\n        }\n\n        // Well-formed entity (ending was found).\n        if (ch === ';') {\n            // Numeric entity.\n            if (str[0] === '#') {\n                if (str[1] === 'x') {\n                    code = +('0' + str.substr(1));\n                } else {\n                    // Removing leading zeros in order to avoid treating as octal in old browsers.\n                    code = +str.substr(1).replace(Regex.LeadingZeros, '');\n                }\n\n                if (!isNaN(code)) {\n                    return String.fromCharCode(code);\n                }\n            } else if (XHTMLEntities[str]) {\n                return XHTMLEntities[str];\n            }\n        }\n\n        // Treat non-entity sequences as regular text.\n        index = start + 1;\n        return '&';\n    }\n\n    function scanXJSText(stopChars) {\n        var ch, str = '', start;\n        start = index;\n        while (index < length) {\n            ch = source[index];\n            if (stopChars.indexOf(ch) !== -1) {\n                break;\n            }\n            if (ch === '&') {\n                str += scanXJSEntity();\n            } else {\n                index++;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    str += ch;\n                    ch = source[index];\n                    index++;\n                }\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    ++lineNumber;\n                    lineStart = index;\n                }\n                str += ch;\n            }\n        }\n        return {\n            type: Token.XJSText,\n            value: str,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanXJSStringLiteral() {\n        var innerToken, quote, start;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        innerToken = scanXJSText([quote]);\n\n        if (quote !== source[index]) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        ++index;\n\n        innerToken.range = [start, index];\n\n        return innerToken;\n    }\n\n    /**\n     * Between XJS opening and closing tags (e.g. <foo>HERE</foo>), anything that\n     * is not another XJS tag and is not an expression wrapped by {} is text.\n     */\n    function advanceXJSChild() {\n        var ch = source.charCodeAt(index);\n\n        // { (123) and < (60)\n        if (ch !== 123 && ch !== 60) {\n            return scanXJSText(['<', '{']);\n        }\n\n        return scanPunctuator();\n    }\n\n    function parseXJSIdentifier() {\n        var token, marker = markerCreate();\n\n        if (lookahead.type !== Token.XJSIdentifier) {\n            throwUnexpected(lookahead);\n        }\n\n        token = lex();\n        return markerApply(marker, delegate.createXJSIdentifier(token.value));\n    }\n\n    function parseXJSNamespacedName() {\n        var namespace, name, marker = markerCreate();\n\n        namespace = parseXJSIdentifier();\n        expect(':');\n        name = parseXJSIdentifier();\n\n        return markerApply(marker, delegate.createXJSNamespacedName(namespace, name));\n    }\n\n    function parseXJSMemberExpression() {\n        var marker = markerCreate(),\n            expr = parseXJSIdentifier();\n\n        while (match('.')) {\n            lex();\n            expr = markerApply(marker, delegate.createXJSMemberExpression(expr, parseXJSIdentifier()));\n        }\n\n        return expr;\n    }\n\n    function parseXJSElementName() {\n        if (lookahead2().value === ':') {\n            return parseXJSNamespacedName();\n        }\n        if (lookahead2().value === '.') {\n            return parseXJSMemberExpression();\n        }\n\n        return parseXJSIdentifier();\n    }\n\n    function parseXJSAttributeName() {\n        if (lookahead2().value === ':') {\n            return parseXJSNamespacedName();\n        }\n\n        return parseXJSIdentifier();\n    }\n\n    function parseXJSAttributeValue() {\n        var value, marker;\n        if (match('{')) {\n            value = parseXJSExpressionContainer();\n            if (value.expression.type === Syntax.XJSEmptyExpression) {\n                throwError(\n                    value,\n                    'XJS attributes must only be assigned a non-empty ' +\n                        'expression'\n                );\n            }\n        } else if (match('<')) {\n            value = parseXJSElement();\n        } else if (lookahead.type === Token.XJSText) {\n            marker = markerCreate();\n            value = markerApply(marker, delegate.createLiteral(lex()));\n        } else {\n            throwError({}, Messages.InvalidXJSAttributeValue);\n        }\n        return value;\n    }\n\n    function parseXJSEmptyExpression() {\n        var marker = markerCreatePreserveWhitespace();\n        while (source.charAt(index) !== '}') {\n            index++;\n        }\n        return markerApply(marker, delegate.createXJSEmptyExpression());\n    }\n\n    function parseXJSExpressionContainer() {\n        var expression, origInXJSChild, origInXJSTag, marker = markerCreate();\n\n        origInXJSChild = state.inXJSChild;\n        origInXJSTag = state.inXJSTag;\n        state.inXJSChild = false;\n        state.inXJSTag = false;\n\n        expect('{');\n\n        if (match('}')) {\n            expression = parseXJSEmptyExpression();\n        } else {\n            expression = parseExpression();\n        }\n\n        state.inXJSChild = origInXJSChild;\n        state.inXJSTag = origInXJSTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createXJSExpressionContainer(expression));\n    }\n\n    function parseXJSSpreadAttribute() {\n        var expression, origInXJSChild, origInXJSTag, marker = markerCreate();\n\n        origInXJSChild = state.inXJSChild;\n        origInXJSTag = state.inXJSTag;\n        state.inXJSChild = false;\n        state.inXJSTag = false;\n\n        expect('{');\n        expect('...');\n\n        expression = parseAssignmentExpression();\n\n        state.inXJSChild = origInXJSChild;\n        state.inXJSTag = origInXJSTag;\n\n        expect('}');\n\n        return markerApply(marker, delegate.createXJSSpreadAttribute(expression));\n    }\n\n    function parseXJSAttribute() {\n        var name, marker;\n\n        if (match('{')) {\n            return parseXJSSpreadAttribute();\n        }\n\n        marker = markerCreate();\n\n        name = parseXJSAttributeName();\n\n        // HTML empty attribute\n        if (match('=')) {\n            lex();\n            return markerApply(marker, delegate.createXJSAttribute(name, parseXJSAttributeValue()));\n        }\n\n        return markerApply(marker, delegate.createXJSAttribute(name));\n    }\n\n    function parseXJSChild() {\n        var token, marker;\n        if (match('{')) {\n            token = parseXJSExpressionContainer();\n        } else if (lookahead.type === Token.XJSText) {\n            marker = markerCreatePreserveWhitespace();\n            token = markerApply(marker, delegate.createLiteral(lex()));\n        } else {\n            token = parseXJSElement();\n        }\n        return token;\n    }\n\n    function parseXJSClosingElement() {\n        var name, origInXJSChild, origInXJSTag, marker = markerCreate();\n        origInXJSChild = state.inXJSChild;\n        origInXJSTag = state.inXJSTag;\n        state.inXJSChild = false;\n        state.inXJSTag = true;\n        expect('<');\n        expect('/');\n        name = parseXJSElementName();\n        // Because advance() (called by lex() called by expect()) expects there\n        // to be a valid token after >, it needs to know whether to look for a\n        // standard JS token or an XJS text node\n        state.inXJSChild = origInXJSChild;\n        state.inXJSTag = origInXJSTag;\n        expect('>');\n        return markerApply(marker, delegate.createXJSClosingElement(name));\n    }\n\n    function parseXJSOpeningElement() {\n        var name, attribute, attributes = [], selfClosing = false, origInXJSChild, origInXJSTag, marker = markerCreate();\n\n        origInXJSChild = state.inXJSChild;\n        origInXJSTag = state.inXJSTag;\n        state.inXJSChild = false;\n        state.inXJSTag = true;\n\n        expect('<');\n\n        name = parseXJSElementName();\n\n        while (index < length &&\n                lookahead.value !== '/' &&\n                lookahead.value !== '>') {\n            attributes.push(parseXJSAttribute());\n        }\n\n        state.inXJSTag = origInXJSTag;\n\n        if (lookahead.value === '/') {\n            expect('/');\n            // Because advance() (called by lex() called by expect()) expects\n            // there to be a valid token after >, it needs to know whether to\n            // look for a standard JS token or an XJS text node\n            state.inXJSChild = origInXJSChild;\n            expect('>');\n            selfClosing = true;\n        } else {\n            state.inXJSChild = true;\n            expect('>');\n        }\n        return markerApply(marker, delegate.createXJSOpeningElement(name, attributes, selfClosing));\n    }\n\n    function parseXJSElement() {\n        var openingElement, closingElement = null, children = [], origInXJSChild, origInXJSTag, marker = markerCreate();\n\n        origInXJSChild = state.inXJSChild;\n        origInXJSTag = state.inXJSTag;\n        openingElement = parseXJSOpeningElement();\n\n        if (!openingElement.selfClosing) {\n            while (index < length) {\n                state.inXJSChild = false; // Call lookahead2() with inXJSChild = false because </ should not be considered in the child\n                if (lookahead.value === '<' && lookahead2().value === '/') {\n                    break;\n                }\n                state.inXJSChild = true;\n                children.push(parseXJSChild());\n            }\n            state.inXJSChild = origInXJSChild;\n            state.inXJSTag = origInXJSTag;\n            closingElement = parseXJSClosingElement();\n            if (getQualifiedXJSName(closingElement.name) !== getQualifiedXJSName(openingElement.name)) {\n                throwError({}, Messages.ExpectedXJSClosingTag, getQualifiedXJSName(openingElement.name));\n            }\n        }\n\n        // When (erroneously) writing two adjacent tags like\n        //\n        //     var x = <div>one</div><div>two</div>;\n        //\n        // the default error message is a bit incomprehensible. Since it's\n        // rarely (never?) useful to write a less-than sign after an XJS\n        // element, we disallow it here in the parser in order to provide a\n        // better error message. (In the rare case that the less-than operator\n        // was intended, the left tag can be wrapped in parentheses.)\n        if (!origInXJSChild && match('<')) {\n            throwError(lookahead, Messages.AdjacentXJSElements);\n        }\n\n        return markerApply(marker, delegate.createXJSElement(openingElement, closingElement, children));\n    }\n\n    function parseTypeAlias() {\n        var id, marker = markerCreate(), typeParameters = null, right;\n        expectContextualKeyword('type');\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('=');\n        right = parseType();\n        consumeSemicolon();\n        return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));\n    }\n\n    function parseInterfaceExtends() {\n        var marker = markerCreate(), id, typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterInstantiation();\n        }\n\n        return markerApply(marker, delegate.createInterfaceExtends(\n            id,\n            typeParameters\n        ));\n    }\n\n    function parseInterfaceish(marker, allowStatic) {\n        var body, bodyMarker, extended = [], id,\n            typeParameters = null;\n\n        id = parseVariableIdentifier();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n\n        if (matchKeyword('extends')) {\n            expectKeyword('extends');\n\n            while (index < length) {\n                extended.push(parseInterfaceExtends());\n                if (!match(',')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        bodyMarker = markerCreate();\n        body = markerApply(bodyMarker, parseObjectType(allowStatic));\n\n        return markerApply(marker, delegate.createInterface(\n            id,\n            typeParameters,\n            body,\n            extended\n        ));\n    }\n\n    function parseInterface() {\n        var body, bodyMarker, extended = [], id, marker = markerCreate(),\n            typeParameters = null;\n\n        expectContextualKeyword('interface');\n        return parseInterfaceish(marker, /* allowStatic */false);\n    }\n\n    function parseDeclareClass() {\n        var marker = markerCreate(), ret;\n        expectContextualKeyword('declare');\n        expectKeyword('class');\n\n        ret = parseInterfaceish(marker, /* allowStatic */true);\n        ret.type = Syntax.DeclareClass;\n        return ret;\n    }\n\n    function parseDeclareFunction() {\n        var id, idMarker,\n            marker = markerCreate(), params, returnType, rest, tmp,\n            typeParameters = null, value, valueMarker;\n\n        expectContextualKeyword('declare');\n        expectKeyword('function');\n        idMarker = markerCreate();\n        id = parseVariableIdentifier();\n\n        valueMarker = markerCreate();\n        if (match('<')) {\n            typeParameters = parseTypeParameterDeclaration();\n        }\n        expect('(');\n        tmp = parseFunctionTypeParams();\n        params = tmp.params;\n        rest = tmp.rest;\n        expect(')');\n\n        expect(':');\n        returnType = parseType();\n\n        value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(\n            params,\n            returnType,\n            rest,\n            typeParameters\n        ));\n\n        id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(\n            value\n        ));\n        markerApply(idMarker, id);\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareFunction(\n            id\n        ));\n    }\n\n    function parseDeclareVariable() {\n        var id, marker = markerCreate();\n        expectContextualKeyword('declare');\n        expectKeyword('var');\n        id = parseTypeAnnotatableIdentifier();\n\n        consumeSemicolon();\n\n        return markerApply(marker, delegate.createDeclareVariable(\n            id\n        ));\n    }\n\n    function parseDeclareModule() {\n        var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;\n        expectContextualKeyword('declare');\n        expectContextualKeyword('module');\n\n        if (lookahead.type === Token.StringLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            idMarker = markerCreate();\n            id = markerApply(idMarker, delegate.createLiteral(lex()));\n        } else {\n            id = parseVariableIdentifier();\n        }\n\n        bodyMarker = markerCreate();\n        expect('{');\n        while (index < length && !match('}')) {\n            token = lookahead2();\n            switch (token.value) {\n            case 'class':\n                body.push(parseDeclareClass());\n                break;\n            case 'function':\n                body.push(parseDeclareFunction());\n                break;\n            case 'var':\n                body.push(parseDeclareVariable());\n                break;\n            default:\n                throwUnexpected(lookahead);\n            }\n        }\n        expect('}');\n\n        return markerApply(marker, delegate.createDeclareModule(\n            id,\n            markerApply(bodyMarker, delegate.createBlockStatement(body))\n        ));\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value, entry;\n\n        if (!state.inXJSChild) {\n            skipComment();\n        }\n\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = extra.advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = extra.scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function patch() {\n        if (extra.comments) {\n            extra.skipComment = skipComment;\n            skipComment = scanComment;\n        }\n\n        if (typeof extra.tokens !== 'undefined') {\n            extra.advance = advance;\n            extra.scanRegExp = scanRegExp;\n\n            advance = collectToken;\n            scanRegExp = collectRegex;\n        }\n    }\n\n    function unpatch() {\n        if (typeof extra.skipComment === 'function') {\n            skipComment = extra.skipComment;\n        }\n\n        if (typeof extra.scanRegExp === 'function') {\n            advance = extra.advance;\n            scanRegExp = extra.scanRegExp;\n        }\n    }\n\n    // This is used to modify the delegate.\n\n    function extend(object, properties) {\n        var entry, result = {};\n\n        for (entry in object) {\n            if (object.hasOwnProperty(entry)) {\n                result[entry] = object[entry];\n            }\n        }\n\n        for (entry in properties) {\n            if (properties.hasOwnProperty(entry)) {\n                result[entry] = properties[entry];\n            }\n        }\n\n        return result;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: true,\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        patch();\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowKeyword: false,\n            allowIn: true,\n            labelSet: {},\n            parenthesizedCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            inXJSChild: false,\n            inXJSTag: false,\n            inType: false,\n            lastCommentStart: -1,\n            yieldAllowed: false,\n            awaitAllowed: false\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                delegate = extend(delegate, {\n                    'postProcess': function (node) {\n                        node.loc.source = toString(options.source);\n                        return node;\n                    }\n                });\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        patch();\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            unpatch();\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '8001.1001.0-dev-harmony-fb';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"]}