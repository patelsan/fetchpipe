"use strict";
var _arguments = arguments;
var arr = [];

// fresh x per iteration but semantics not determined yet
// in ES6 spec draft (transfer in particular). Also inconsistent
// between VM implementations.
// once ES6 nails down the semantics (and VM's catch up) we'll
// revisit
// note v8 bug https://code.google.com/p/v8/issues/detail?id=2560
// also see other/v8-bug.js

var _loop = function (x) {
    arr.push(function () {
        return x;
    });
};

for (var x = 0; x < 3; x++) {
    _loop(x);
}

var _loop2 = function (x, _z) {
    arr.push(function () {
        return x;
    });
};

for (var _z = undefined, x = 0; x < 3; x++) {
    _loop2(x, _z);
}

// as a consequence of the above, defs is unable to transform
// the code below (even though it is the output of an earlier
// defs transformation). we should be able to detect this case
// (and pass it through unmodified) but is it worth the effort?

var _loop3 = function (x) {
    (function () {
        var y = x;
        arr.push(function () {
            return y;
        });
    }).call(undefined);
};

for (var x = 0; x < 3; x++) {
    _loop3(x);
}

// return is not allowed inside the loop body because the IIFE would break it
(function () {
    var _loop4 = function (x) {
        var y = x;
        return {
            v: 1
        };
        arr.push(function () {
            return y;
        });
    };

    for (var x = 0; x < 3; x++) {
        var _ret4 = _loop4(x);

        if (typeof _ret4 === "object") return _ret4.v;
    }
})();

// break is not allowed inside the loop body because the IIFE would break it

var _loop5 = function (x) {
    var y = x;
    return "break";
    arr.push(function () {
        return y;
    });
};

for (var x = 0; x < 3; x++) {
    var _ret5 = _loop5(x);

    if (_ret5 === "break") break;
}

// continue is not allowed inside the loop body because the IIFE would break it

var _loop6 = function (x) {
    var y = x;
    return "continue";
    arr.push(function () {
        return y;
    });
};

for (var x = 0; x < 3; x++) {
    var _ret6 = _loop6(x);

    if (_ret6 === "continue") continue;
}

// arguments is not allowed inside the loop body because the IIFE would break it
// (and I don't want to re-apply outer arguments in the inserted IIFE)

var _loop7 = function (x) {
    var y = x;
    _arguments[0];
    arr.push(function () {
        return y;
    });
};

for (var x = 0; x < 3; x++) {
    _loop7(x);
}

// continue is not allowed inside the loop body because the IIFE would break it

var _loop8 = function (x) {
    var y = x;
    z = 1;

    arr.push(function () {
        return y;
    });
};

for (var x = 0; x < 3; x++) {
    var z;

    _loop8(x);
}

// TODO block-less loops (is that even applicable?)

arr.forEach(function (f) {
    console.log(f());
});

//# sourceMappingURL=forbidden-loop-closure-compiled.js.map