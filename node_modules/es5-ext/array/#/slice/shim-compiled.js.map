{"version":3,"sources":["shim.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;AAEb,IAAI,SAAS,GAAM,OAAO,CAAC,4BAA4B,CAAC;IACpD,QAAQ,GAAO,OAAO,CAAC,gCAAgC,CAAC;IACxD,YAAY,GAAG,OAAO,CAAC,sBAAsB,CAAC;IAE9C,OAAO,GAAG,KAAK,CAAC,OAAO;IAAE,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK;IACtD,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc;IAAE,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;;AAErE,MAAM,CAAC,OAAO,GAAG,UAAU,KAAK,EAAE,GAAG,EAAE;AACtC,KAAI,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;AACtB,KAAI,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;AAClD,SAAO,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;EACpC;AACD,OAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAC/B,MAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;AACzB,KAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,MAAM,GAAG,KAAK,EAAE,CAAC,CAAC,CAAC,KACzC,IAAI,KAAK,GAAG,MAAM,EAAE,KAAK,GAAG,MAAM,CAAC;AACxC,KAAI,GAAG,KAAK,SAAS,EAAE;AACtB,KAAG,GAAG,MAAM,CAAC;EACb,MAAM;AACN,KAAG,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC;AACrB,MAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,GAAG,CAAC,MAAM,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,KACnC,IAAI,GAAG,GAAG,MAAM,EAAE,GAAG,GAAG,MAAM,CAAC;EACpC;AACD,KAAI,KAAK,GAAG,GAAG,EAAE,KAAK,GAAG,GAAG,CAAC;AAC7B,OAAM,GAAG,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;AAC3C,EAAC,GAAG,CAAC,CAAC;AACN,QAAO,KAAK,KAAK,GAAG,EAAE;AACrB,MAAI,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9D,IAAE,CAAC,CAAC;AACJ,IAAE,KAAK,CAAC;EACR;AACD,QAAO,MAAM,CAAC;CACd,CAAC","file":"shim-compiled.js","sourcesContent":["'use strict';\n\nvar toInteger    = require('../../../number/to-integer')\n  , toPosInt     = require('../../../number/to-pos-integer')\n  , isPlainArray = require('../../is-plain-array')\n\n  , isArray = Array.isArray, slice = Array.prototype.slice\n  , hasOwnProperty = Object.prototype.hasOwnProperty, max = Math.max;\n\nmodule.exports = function (start, end) {\n\tvar length, result, i;\n\tif (!this || !isArray(this) || isPlainArray(this)) {\n\t\treturn slice.apply(this, arguments);\n\t}\n\tlength = toPosInt(this.length);\n\tstart = toInteger(start);\n\tif (start < 0) start = max(length + start, 0);\n\telse if (start > length) start = length;\n\tif (end === undefined) {\n\t\tend = length;\n\t} else {\n\t\tend = toInteger(end);\n\t\tif (end < 0) end = max(length + end, 0);\n\t\telse if (end > length) end = length;\n\t}\n\tif (start > end) start = end;\n\tresult = new this.constructor(end - start);\n\ti = 0;\n\twhile (start !== end) {\n\t\tif (hasOwnProperty.call(this, start)) result[i] = this[start];\n\t\t++i;\n\t\t++start;\n\t}\n\treturn result;\n};\n"]}