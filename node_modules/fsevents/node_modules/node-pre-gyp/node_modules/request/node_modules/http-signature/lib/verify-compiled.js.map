{"version":3,"sources":["verify.js"],"names":[],"mappings":";;;;AAEA,IAAI,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AACpC,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;;;;AAM/B,MAAM,CAAC,OAAO,GAAG;;;;;;;;;;AAUf,iBAAe,EAAE,SAAS,eAAe,CAAC,eAAe,EAAE,MAAM,EAAE;AACjE,UAAM,CAAC,MAAM,CAAC,eAAe,EAAE,iBAAiB,CAAC,CAAC;AAClD,UAAM,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;;AAEhC,QAAI,GAAG,GAAG,eAAe,CAAC,SAAS,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;AAC9D,QAAI,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAC1B,MAAM,IAAI,SAAS,CAAC,yCAAyC,GACzC,eAAe,CAAC,SAAS,CAAC,CAAC;;AAEjD,QAAI,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACzC,UAAM,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;AAC7C,WAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,eAAe,CAAC,MAAM,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;GAC1E;;;;;;;;;;;AAWD,YAAU,EAAE,SAAS,UAAU,CAAC,eAAe,EAAE,MAAM,EAAE;AACvD,UAAM,CAAC,MAAM,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;AAC7C,UAAM,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;;AAEhC,QAAI,GAAG,GAAG,eAAe,CAAC,SAAS,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;AACzD,QAAI,CAAC,GAAG,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAC1B,MAAM,IAAI,SAAS,CAAC,yCAAyC,GACzC,eAAe,CAAC,SAAS,CAAC,CAAC;;AAEjD,QAAI,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,MAAM,CAAC,CAAC;AAC3D,QAAI,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;AAC3C,WAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,eAAe,CAAC,MAAM,CAAC,SAAS,CAAE;GACrE;CACF,CAAC","file":"verify-compiled.js","sourcesContent":["// Copyright 2015 Joyent, Inc.\n\nvar assert = require('assert-plus');\nvar crypto = require('crypto');\n\n\n\n///--- Exported API\n\nmodule.exports = {\n  /**\n   * Verify RSA/DSA signature against public key.  You are expected to pass in\n   * an object that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} pubkey RSA/DSA private key PEM.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   */\n  verifySignature: function verifySignature(parsedSignature, pubkey) {\n    assert.object(parsedSignature, 'parsedSignature');\n    assert.string(pubkey, 'pubkey');\n\n    var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\\w+)/);\n    if (!alg || alg.length !== 3)\n      throw new TypeError('parsedSignature: unsupported algorithm ' +\n                          parsedSignature.algorithm);\n\n    var verify = crypto.createVerify(alg[0]);\n    verify.update(parsedSignature.signingString);\n    return verify.verify(pubkey, parsedSignature.params.signature, 'base64');\n  },\n\n  /**\n   * Verify HMAC against shared secret.  You are expected to pass in an object\n   * that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} secret HMAC shared secret.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   */\n  verifyHMAC: function verifyHMAC(parsedSignature, secret) {\n    assert.object(parsedSignature, 'parsedHMAC');\n    assert.string(secret, 'secret');\n\n    var alg = parsedSignature.algorithm.match(/^HMAC-(\\w+)/);\n    if (!alg || alg.length !== 2)\n      throw new TypeError('parsedSignature: unsupported algorithm ' +\n                          parsedSignature.algorithm);\n\n    var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);\n    hmac.update(parsedSignature.signingString);\n    return (hmac.digest('base64') === parsedSignature.params.signature);\n  }\n};\n"]}