{"version":3,"sources":["ctf.js"],"names":[],"mappings":"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","file":"ctf-compiled.js","sourcesContent":["/*\n * ctf.js\n *\n * Understand and parse all of the different JSON formats of CTF data and\n * translate that into a series of node-ctype friendly pieces. The reason for\n * the abstraction is to handle different changes in the file format.\n *\n * We have to be careful here that we don't end up using a name that is already\n * a built in type.\n */\nvar mod_assert = require('assert');\nvar ASSERT = mod_assert.ok;\n\nvar ctf_versions = [ '1.0' ];\nvar ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];\nvar ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',\n    'uint32_t', 'float', 'double' ];\n\nfunction ctfParseInteger(entry, ctype)\n{\n\tvar name, sign, len, type;\n\n\tname = entry['name'];\n\tif (!('signed' in entry['integer']))\n\t\tthrow (new Error('Malformed CTF JSON: integer missing ' +\n\t\t    'signed value'));\n\n\n\tif (!('length' in entry['integer']))\n\t\tthrow (new Error('Malformed CTF JSON: integer missing ' +\n\t\t    'length value'));\n\n\tsign = entry['integer']['signed'];\n\tlen = entry['integer']['length'];\n\ttype = null;\n\n\tif (sign && len == 1)\n\t\ttype = 'int8_t';\n\telse if (len == 1)\n\t\ttype = 'uint8_t';\n\telse if (sign && len == 2)\n\t\ttype = 'int16_t';\n\telse if (len == 2)\n\t\ttype = 'uint16_t';\n\telse if (sign && len == 4)\n\t\ttype = 'int32_t';\n\telse if (len == 4)\n\t\ttype = 'uint32_t';\n\telse if (sign && len == 8)\n\t\ttype = 'int64_t';\n\telse if (len == 8)\n\t\ttype = 'uint64_t';\n\n\tif (type === null)\n\t\tthrow (new Error('Malformed CTF JSON: integer has ' +\n\t\t    'unsupported length and sign - ' + len + '/' + sign));\n\n\t/*\n\t * This means that this is the same as one of our built in types. If\n\t * that's the case defining it would be an error. So instead of trying\n\t * to typedef it, we'll return here.\n\t */\n\tif (name == type)\n\t\treturn;\n\n\tif (name == 'char') {\n\t\tASSERT(type == 'int8_t');\n\t\treturn;\n\t}\n\n\tctype.typedef(name, type);\n}\n\nfunction ctfParseFloat(entry, ctype)\n{\n\tvar name, len;\n\n\tname = entry['name'];\n\tif (!('length' in entry['float']))\n\t\tthrow (new Error('Malformed CTF JSON: float missing ' +\n\t\t    'length value'));\n\n\tlen = entry['float']['length'];\n\tif (len != 4 && len != 8)\n\t\tthrow (new Error('Malformed CTF JSON: float has invalid ' +\n\t\t    'length value'));\n\n\tif (len == 4) {\n\t\tif (name == 'float')\n\t\t\treturn;\n\t\tctype.typedef(name, 'float');\n\t} else if (len == 8) {\n\t\tif (name == 'double')\n\t\t\treturn;\n\t\tctype.typedef(name, 'double');\n\t}\n}\n\nfunction ctfParseTypedef(entry, ctype)\n{\n\tvar name, type, ii;\n\n\tname = entry['name'];\n\tif (typeof (entry['typedef']) != 'string')\n\t\tthrow (new Error('Malformed CTF JSON: typedef value in not ' +\n\t\t    'a string'));\n\n\ttype = entry['typedef'];\n\n\t/*\n\t * We need to ensure that we're not looking at type that's one of our\n\t * built in types. Traditionally in C a uint32_t would be a typedef to\n\t * some kind of integer. However, those size types are built ins.\n\t */\n\tfor (ii = 0; ii < ctf_deftypes.length; ii++) {\n\t\tif (name == ctf_deftypes[ii])\n\t\t\treturn;\n\t}\n\n\tctype.typedef(name, type);\n}\n\nfunction ctfParseStruct(entry, ctype)\n{\n\tvar name, type, ii, val, index, member, push;\n\n\tmember = [];\n\tif (!Array.isArray(entry['struct']))\n\t\tthrow (new Error('Malformed CTF JSON: struct value is not ' +\n\t\t    'an array'));\n\n\tfor (ii = 0; ii < entry['struct'].length; ii++) {\n\t\tval = entry['struct'][ii];\n\t\tif (!('name' in val))\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'missing name'));\n\n\t\tif (!('type' in val))\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'missing type'));\n\n\t\tif (typeof (val['name']) != 'string')\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'name isn\\'t a string'));\n\n\t\tif (typeof (val['type']) != 'string')\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'type isn\\'t a string'));\n\n\t\t/*\n\t\t * CTF version 2 specifies array names as <type> [<num>] where\n\t\t * as node-ctype does this as <type>[<num>].\n\t\t */\n\t\tname = val['name'];\n\t\ttype = val['type'];\n\t\tindex = type.indexOf(' [');\n\t\tif (index != -1) {\n\t\t\ttype = type.substring(0, index) +\n\t\t\t    type.substring(index + 1, type.length);\n\t\t}\n\t\tpush = {};\n\t\tpush[name] = { 'type': type };\n\t\tmember.push(push);\n\t}\n\n\tname = entry['name'];\n\tctype.typedef(name, member);\n}\n\nfunction ctfParseEntry(entry, ctype)\n{\n\tvar ii, found;\n\n\tif (!('name' in entry))\n\t\tthrow (new Error('Malformed CTF JSON: entry missing \"name\" ' +\n\t\t    'section'));\n\n\tfor (ii = 0; ii < ctf_entries.length; ii++) {\n\t\tif (ctf_entries[ii] in entry)\n\t\t\tfound++;\n\t}\n\n\tif (found === 0)\n\t\tthrow (new Error('Malformed CTF JSON: found no entries'));\n\n\tif (found >= 2)\n\t\tthrow (new Error('Malformed CTF JSON: found more than one ' +\n\t\t    'entry'));\n\n\tif ('integer' in entry) {\n\t\tctfParseInteger(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('float' in entry) {\n\t\tctfParseFloat(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('typedef' in entry) {\n\t\tctfParseTypedef(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('struct' in entry) {\n\t\tctfParseStruct(entry, ctype);\n\t\treturn;\n\t}\n\n\tASSERT(false, 'shouldn\\'t reach here');\n}\n\nfunction ctfParseJson(json, ctype)\n{\n\tvar version, ii;\n\n\tASSERT(json);\n\tASSERT(ctype);\n\tif (!('metadata' in json))\n\t\tthrow (new Error('Invalid CTF JSON: missing metadata section'));\n\n\tif (!('ctf2json_version' in json['metadata']))\n\t\tthrow (new Error('Invalid CTF JSON: missing ctf2json_version'));\n\n\tversion = json['metadata']['ctf2json_version'];\n\tfor (ii = 0; ii < ctf_versions.length; ii++) {\n\t\tif (ctf_versions[ii] == version)\n\t\t\tbreak;\n\t}\n\n\tif (ii == ctf_versions.length)\n\t\tthrow (new Error('Unsuported ctf2json_version: ' + version));\n\n\tif (!('data' in json))\n\t\tthrow (new Error('Invalid CTF JSON: missing data section'));\n\n\tif (!Array.isArray(json['data']))\n\t\tthrow (new Error('Malformed CTF JSON: data section is not ' +\n\t\t    'an array'));\n\n\tfor (ii = 0; ii < json['data'].length; ii++)\n\t\tctfParseEntry(json['data'][ii], ctype);\n}\n\nexports.ctfParseJson = ctfParseJson;\n"]}