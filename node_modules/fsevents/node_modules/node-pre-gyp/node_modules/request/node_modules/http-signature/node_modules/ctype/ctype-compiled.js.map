{"version":3,"sources":["ctype.js"],"names":[],"mappings":"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AM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;;AAEnC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;;AAEnC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;AACnC,OAAO,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACjC,OAAO,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC","file":"ctype-compiled.js","sourcesContent":["/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\n\nvar mod_ctf = require('./ctf.js');\nvar mod_ctio = require('./ctio.js');\nvar mod_assert = require('assert');\n\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\nvar deftypes = {\n    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },\n    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },\n    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },\n    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },\n    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },\n    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },\n    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },\n    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },\n    'float': { read: ctReadFloat, write: ctWriteFloat },\n    'double': { read: ctReadDouble, write: ctWriteDouble },\n    'char': { read: ctReadChar, write: ctWriteChar },\n    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }\n};\n\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\nfunction ctReadUint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadUint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadUint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadUint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadSint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadSint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadSint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadSint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadFloat(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rfloat(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadDouble(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rdouble(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\n/*\n * Reads a single character into a node buffer\n */\nfunction ctReadChar(endian, buffer, offset)\n{\n\tvar res = new Buffer(1);\n\tres[0] = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: res, size: 1 });\n}\n\nfunction ctReadCharArray(length, endian, buffer, offset)\n{\n\tvar ii;\n\tvar res = new Buffer(length);\n\n\tfor (ii = 0; ii < length; ii++)\n\t\tres[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n\n\treturn ({ value: res, size: length });\n}\n\nfunction ctWriteUint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteUint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteUint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteUint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteSint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteSint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteSint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteSint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteFloat(value, endian, buffer, offset)\n{\n\tmod_ctio.wfloat(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteDouble(value, endian, buffer, offset)\n{\n\tmod_ctio.wdouble(value, endian, buffer, offset);\n\treturn (8);\n}\n\n/*\n * Writes a single character into a node buffer\n */\nfunction ctWriteChar(value, endian, buffer, offset)\n{\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tmod_ctio.ruint8(value[0], endian, buffer, offset);\n\treturn (1);\n}\n\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\nfunction ctWriteCharArray(value, length, endian, buffer, offset)\n{\n\tvar ii;\n\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tif (value.length > length)\n\t\tthrow (new Error('value length greater than array length'));\n\n\tfor (ii = 0; ii < value.length && ii < length; ii++)\n\t\tmod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n\n\tfor (; ii < length; ii++)\n\t\tmod_ctio.wuint8(0, endian, offset + ii);\n\n\n\treturn (length);\n}\n\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\nfunction ctGetBasicTypes()\n{\n\tvar ret = {};\n\tvar key;\n\tfor (key in deftypes)\n\t\tret[key] = deftypes[key];\n\n\treturn (ret);\n}\n\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\nfunction ctParseType(str)\n{\n\tvar begInd, endInd;\n\tvar type, len;\n\tif (typeof (str) != 'string')\n\t\tthrow (new Error('type must be a Javascript string'));\n\n\tendInd = str.lastIndexOf(']');\n\tif (endInd == -1) {\n\t\tif (str.lastIndexOf('[') != -1)\n\t\t\tthrow (new Error('found invalid type with \\'[\\' but ' +\n\t\t\t    'no corresponding \\']\\''));\n\n\t\treturn ({ type: str });\n\t}\n\n\tbegInd = str.lastIndexOf('[');\n\tif (begInd == -1)\n\t\tthrow (new Error('found invalid type with \\']\\' but ' +\n\t\t    'no corresponding \\'[\\''));\n\n\tif (begInd >= endInd)\n\t\tthrow (new Error('malformed type, \\']\\' appears before \\'[\\''));\n\n\ttype = str.substring(0, begInd);\n\tlen = str.substring(begInd + 1, endInd);\n\n\treturn ({ type: type, len: len });\n}\n\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\nfunction ctCheckReq(def, types, fields)\n{\n\tvar ii, jj;\n\tvar req, keys, key;\n\tvar found = {};\n\n\tif (!(def instanceof Array))\n\t\tthrow (new Error('definition is not an array'));\n\n\tif (def.length === 0)\n\t\tthrow (new Error('definition must have at least one element'));\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\treq = def[ii];\n\t\tif (!(req instanceof Object))\n\t\t\tthrow (new Error('definition must be an array of' +\n\t\t\t    'objects'));\n\n\t\tkeys = Object.keys(req);\n\t\tif (keys.length != 1)\n\t\t\tthrow (new Error('definition entry must only have ' +\n\t\t\t    'one key'));\n\n\t\tif (keys[0] in found)\n\t\t\tthrow (new Error('Specified name already ' +\n\t\t\t    'specified: ' + keys[0]));\n\n\t\tif (!('type' in req[keys[0]]))\n\t\t\tthrow (new Error('missing required type definition'));\n\n\t\tkey = ctParseType(req[keys[0]]['type']);\n\n\t\t/*\n\t\t * We may have nested arrays, we need to check the validity of\n\t\t * the types until the len field is undefined in key. However,\n\t\t * each time len is defined we need to verify it is either an\n\t\t * integer or corresponds to an already seen key.\n\t\t */\n\t\twhile (key['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(key['len'], 10))) {\n\t\t\t\tif (!(key['len'] in found))\n\t\t\t\t\tthrow (new Error('Given an array ' +\n\t\t\t\t\t    'length without a matching type'));\n\n\t\t\t}\n\n\t\t\tkey = ctParseType(key['type']);\n\t\t}\n\n\t\t/* Now we can validate if the type is valid */\n\t\tif (!(key['type'] in types))\n\t\t\tthrow (new Error('type not found or typdefed: ' +\n\t\t\t    key['type']));\n\n\t\t/* Check for any required fields */\n\t\tif (fields !== undefined) {\n\t\t\tfor (jj = 0; jj < fields.length; jj++) {\n\t\t\t\tif (!(fields[jj] in req[keys[0]]))\n\t\t\t\t\tthrow (new Error('Missing required ' +\n\t\t\t\t\t    'field: ' + fields[jj]));\n\t\t\t}\n\t\t}\n\n\t\tfound[keys[0]] = true;\n\t}\n}\n\n\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\nfunction CTypeParser(conf)\n{\n\tif (!conf) throw (new Error('missing required argument'));\n\n\tif (!('endian' in conf))\n\t\tthrow (new Error('missing required endian value'));\n\n\tif (conf['endian'] != 'big' && conf['endian'] != 'little')\n\t\tthrow (new Error('Invalid endian type'));\n\n\tif ('char-type' in conf && (conf['char-type'] != 'uint8' &&\n\t    conf['char-type'] != 'int8'))\n\t\tthrow (new Error('invalid option for char-type: ' +\n\t\t    conf['char-type']));\n\n\tthis.endian = conf['endian'];\n\tthis.types = ctGetBasicTypes();\n\n\t/*\n\t * There may be a more graceful way to do this, but this will have to\n\t * serve.\n\t */\n\tif ('char-type' in conf && conf['char-type'] == 'uint8')\n\t\tthis.types['char'] = this.types['uint8_t'];\n\n\tif ('char-type' in conf && conf['char-type'] == 'int8')\n\t\tthis.types['char'] = this.types['int8_t'];\n}\n\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\nCTypeParser.prototype.setEndian = function (endian)\n{\n\tif (endian != 'big' && endian != 'little')\n\t\tthrow (new Error('invalid endian type, must be big or ' +\n\t\t    'little'));\n\n\tthis.endian = endian;\n};\n\n/*\n * Returns the current value of the endian value for the parser.\n */\nCTypeParser.prototype.getEndian = function ()\n{\n\treturn (this.endian);\n};\n\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\nCTypeParser.prototype.typedef = function (name, value)\n{\n\tvar type;\n\n\tif (name === undefined)\n\t\tthrow (new (Error('missing required typedef argument: name')));\n\n\tif (value === undefined)\n\t\tthrow (new (Error('missing required typedef argument: value')));\n\n\tif (typeof (name) != 'string')\n\t\tthrow (new (Error('the name of a type must be a string')));\n\n\ttype = ctParseType(name);\n\n\tif (type['len'] !== undefined)\n\t\tthrow (new Error('Cannot have an array in the typedef name'));\n\n\tif (name in this.types)\n\t\tthrow (new Error('typedef name already present: ' + name));\n\n\tif (typeof (value) != 'string' && !(value instanceof Array))\n\t\tthrow (new Error('typedef value must either be a string or ' +\n\t\t    'struct'));\n\n\tif (typeof (value) == 'string') {\n\t\ttype = ctParseType(value);\n\t\tif (type['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(type['len'], 10)))\n\t\t\t\tthrow (new (Error('typedef value must use ' +\n\t\t\t\t    'fixed size array when outside of a ' +\n\t\t\t\t    'struct')));\n\t\t}\n\n\t\tthis.types[name] = value;\n\t} else {\n\t\t/* We have a struct, validate it */\n\t\tctCheckReq(value, this.types);\n\t\tthis.types[name] = value;\n\t}\n};\n\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\nCTypeParser.prototype.lstypes = function ()\n{\n\tvar key;\n\tvar ret = {};\n\n\tfor (key in this.types) {\n\t\tif (key in deftypes)\n\t\t\tcontinue;\n\t\tret[key] = this.types[key];\n\t}\n\n\treturn (ret);\n};\n\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\nfunction ctResolveArray(str, values)\n{\n\tvar ret = '';\n\tvar type = ctParseType(str);\n\n\twhile (type['len'] !== undefined) {\n\t\tif (isNaN(parseInt(type['len'], 10))) {\n\t\t\tif (typeof (values[type['len']]) != 'number')\n\t\t\t\tthrow (new Error('cannot sawp in non-number ' +\n\t\t\t\t    'for array value'));\n\t\t\tret = '[' + values[type['len']] + ']' + ret;\n\t\t} else {\n\t\t\tret = '[' + type['len'] + ']' + ret;\n\t\t}\n\t\ttype = ctParseType(type['type']);\n\t}\n\n\tret = type['type'] + ret;\n\n\treturn (ret);\n}\n\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,\n    offset, value)\n{\n\tvar pt;\n\n\tmod_assert.ok(type in this.types);\n\tif (typeof (this.types[type]) == 'string') {\n\t\tpt = ctParseType(this.types[type]);\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readEntry(pt, buffer, offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeEntry(value, pt, buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t} else {\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readStruct(this.types[type], buffer,\n\t\t\t    offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeStruct(value, this.types[type],\n\t\t\t    buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t}\n\n};\n\n/*\n * [private] Try and read in the specific entry.\n */\nCTypeParser.prototype.readEntry = function (type, buffer, offset)\n{\n\tvar parse, len;\n\n\t/*\n\t * Because we want to special case char[]s this is unfortunately\n\t * a bit uglier than it really should be. We want to special\n\t * case char[]s so that we return a node buffer, thus they are a\n\t * first class type where as all other arrays just call into a\n\t * generic array routine which calls their data-specific routine\n\t * the specified number of times.\n\t *\n\t * The valid dispatch options we have are:\n\t *  - Array and char => char[] handler\n\t *  - Generic array handler\n\t *  - Generic typedef handler\n\t *  - Basic type handler\n\t */\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tparse = this.types['char[]']['read'](len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tparse = this.readArray(type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tparse = this.types[type['type']]['read'](this.endian,\n\t\t\t    buffer, offset);\n\t\telse\n\t\t\tparse = this.resolveTypedef(type['type'], 'read',\n\t\t\t    buffer, offset);\n\t}\n\n\treturn (parse);\n};\n\n/*\n * [private] Read an array of data\n */\nCTypeParser.prototype.readArray = function (type, length, buffer, offset)\n{\n\tvar ii, ent, pt;\n\tvar baseOffset = offset;\n\tvar ret = new Array(length);\n\tpt = ctParseType(type);\n\n\tfor (ii = 0; ii < length; ii++) {\n\t\tent = this.readEntry(pt, buffer, offset);\n\t\toffset += ent['size'];\n\t\tret[ii] = ent['value'];\n\t}\n\n\treturn ({ value: ret, size: offset - baseOffset });\n};\n\n/*\n * [private] Read a single struct in.\n */\nCTypeParser.prototype.readStruct = function (def, buffer, offset)\n{\n\tvar parse, ii, type, entry, key;\n\tvar baseOffset = offset;\n\tvar ret = {};\n\n\t/* Walk it and handle doing what's necessary */\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\t/* Resolve all array values */\n\t\ttype = ctParseType(ctResolveArray(entry['type'], ret));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\tparse = this.readEntry(type, buffer, offset);\n\n\t\toffset += parse['size'];\n\t\tret[key] = parse['value'];\n\t}\n\n\treturn ({ value: ret, size: (offset-baseOffset)});\n};\n\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\nCTypeParser.prototype.readData = function (def, buffer, offset)\n{\n\t/* Sanity check for arguments */\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\t/* Sanity check the object definition */\n\tctCheckReq(def, this.types);\n\n\treturn (this.readStruct(def, buffer, offset)['value']);\n};\n\n/*\n * [private] Write out an array of data\n */\nCTypeParser.prototype.writeArray = function (value, type, length, buffer,\n    offset)\n{\n\tvar ii, pt;\n\tvar baseOffset = offset;\n\tif (!(value instanceof Array))\n\t\tthrow (new Error('asked to write an array, but value is not ' +\n\t\t    'an array'));\n\n\tif (value.length != length)\n\t\tthrow (new Error('asked to write array of length ' + length +\n\t\t    ' but that does not match value length: ' + value.length));\n\n\tpt = ctParseType(type);\n\tfor (ii = 0; ii < length; ii++)\n\t\toffset += this.writeEntry(value[ii], pt, buffer, offset);\n\n\treturn (offset - baseOffset);\n};\n\n/*\n * [private] Write the specific entry\n */\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset)\n{\n\tvar len, ret;\n\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tret = this.types['char[]']['write'](value, len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.writeArray(value, type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tret = this.types[type['type']]['write'](value,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.resolveTypedef(type['type'], 'write',\n\t\t\t    buffer, offset, value);\n\t}\n\n\treturn (ret);\n};\n\n/*\n * [private] Write a single struct out.\n */\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset)\n{\n\tvar ii, entry, type, key;\n\tvar baseOffset = offset;\n\tvar vals = {};\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\ttype = ctParseType(ctResolveArray(entry['type'], vals));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\toffset += this.writeEntry(value[ii], type, buffer, offset);\n\t\t/* Now that we've written it out, we can use it for arrays */\n\t\tvals[key] = value[ii];\n\t}\n\n\treturn (offset);\n};\n\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\nfunction getValues(def)\n{\n\tvar ii, out, key;\n\tout = [];\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tmod_assert.ok('value' in def[ii][key]);\n\t\tout.push(def[ii][key]['value']);\n\t}\n\n\treturn (out);\n}\n\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\nCTypeParser.prototype.writeData = function (def, buffer, offset, values)\n{\n\tvar hv;\n\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\thv = (values != null && values != undefined);\n\tif (hv) {\n\t\tif (!Array.isArray(values))\n\t\t\tthrow (new Error('missing values for writing'));\n\t\tctCheckReq(def, this.types);\n\t} else {\n\t\tctCheckReq(def, this.types, [ 'value' ]);\n\t}\n\n\tthis.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toAbs64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\t/* We have 20 bits worth of precision in this range */\n\tif (val[0] >= 0x100000)\n\t\tthrow (new Error('value would become approximated'));\n\n\treturn (val[0] * Math.pow(2, 32) + val[1]);\n}\n\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toApprox64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\treturn (Math.pow(2, 32) * val[0] + val[1]);\n}\n\nfunction parseCTF(json, conf)\n{\n\tvar ctype = new CTypeParser(conf);\n\tmod_ctf.ctfParseJson(json, ctype);\n\n\treturn (ctype);\n}\n\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\n\nexports.parseCTF = parseCTF;\n\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\n\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\n\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;\n"]}