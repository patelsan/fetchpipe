{"version":3,"sources":["block-stream.js"],"names":[],"mappings":";;;;;;AAIA,MAAM,CAAC,OAAO,GAAG,WAAW,CAAA;;AAE5B,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM;IACjC,QAAQ,GAAG,OAAO,CAAC,UAAU,CAAC;IAC9B,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,EAAE;IAC7B,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,GAAG,YAAY,EAAE,CAAA;;AAE9D,SAAS,WAAW,CAAE,IAAI,EAAE,GAAG,EAAE;AAC/B,MAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA;AACpC,MAAI,CAAC,IAAI,GAAG,GAAG,IAAI,EAAE,CAAA;AACrB,MAAI,CAAC,UAAU,GAAG,IAAI,IAAI,GAAG,CAAA;AAC7B,MAAI,CAAC,OAAO,GAAG,CAAC,CAAA;AAChB,MAAI,CAAC,OAAO,GAAG,EAAE,CAAA;AACjB,MAAI,CAAC,aAAa,GAAG,CAAC,CAAA;AACtB,MAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,GAAG,KAAK,CAAA,KACpC;AACH,QAAI,CAAC,OAAO,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;AAC1C,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC,EAAG,EAAE;AACzC,UAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;KACpB;GACF;CACF;;AAED,QAAQ,CAAC,WAAW,EAAE,MAAM,CAAC,CAAA;;AAE7B,WAAW,CAAC,SAAS,CAAC,KAAK,GAAG,UAAU,CAAC,EAAE;;AAEzC,MAAI,IAAI,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAA;AAChE,MAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAA;AACpD,MAAI,CAAC,CAAC,MAAM,EAAE;AACZ,QAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACpB,QAAI,CAAC,aAAa,IAAI,CAAC,CAAC,MAAM,CAAA;GAC/B;;AAED,MAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,UAAU,EAAE;AACzC,QAAI,IAAI,CAAC,OAAO,EAAE;;AAEhB,UAAI,CAAC,UAAU,GAAG,IAAI,CAAA;AACtB,aAAO,KAAK,CAAA;KACb;AACD,QAAI,CAAC,UAAU,EAAE,CAAA;GAClB;AACD,SAAO,IAAI,CAAA;CACZ,CAAA;;AAED,WAAW,CAAC,SAAS,CAAC,KAAK,GAAG,YAAY;;AAExC,MAAI,CAAC,OAAO,GAAG,IAAI,CAAA;CACpB,CAAA;;AAED,WAAW,CAAC,SAAS,CAAC,MAAM,GAAG,YAAY;;AAEzC,MAAI,CAAC,OAAO,GAAG,KAAK,CAAA;AACpB,SAAO,IAAI,CAAC,UAAU,EAAE,CAAA;CACzB,CAAA;;AAED,WAAW,CAAC,SAAS,CAAC,GAAG,GAAG,UAAU,KAAK,EAAE;;AAE3C,MAAI,OAAO,KAAK,KAAK,UAAU,EAAE,EAAE,GAAG,KAAK,EAAE,KAAK,GAAG,IAAI,CAAA;AACzD,MAAI,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;AAC5B,MAAI,CAAC,MAAM,GAAG,IAAI,CAAA;AAClB,MAAI,CAAC,KAAK,EAAE,CAAA;CACb,CAAA;;AAED,WAAW,CAAC,SAAS,CAAC,KAAK,GAAG,YAAY;AACxC,MAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;CACtB,CAAA;;AAED,WAAW,CAAC,SAAS,CAAC,UAAU,GAAG,UAAU,KAAK,EAAE;;;;AAIlD,MAAI,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE;;;AAGzB,QAAI,QAAQ,GAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,AAAC,CAAA;AACrD,QAAI,QAAQ,KAAK,CAAC,EAAE,QAAQ,GAAG,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAA;AACzD,QAAI,QAAQ,GAAG,CAAC,EAAE;;AAEhB,UAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAA;AAClD,UAAI,CAAC,aAAa,IAAI,QAAQ,CAAA;;KAE/B;GACF;;AAED,MAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,EAAE,OAAM;AAC1C,MAAI,CAAC,SAAS,GAAG,IAAI,CAAA;;;AAGrB,MAAI,WAAW,GAAG,CAAC,CAAA;AACnB,SAAO,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,UAAU,KACpC,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,CAAA,AAAC,EAAE;;;AAG/B,QAAI,GAAG;QACH,SAAS,GAAG,CAAC;QACb,MAAM,GAAG,IAAI,CAAC,UAAU,CAAA;;AAE5B,WAAO,MAAM,GAAG,CAAC,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,CAAA,AAAC,EAAG;;AAE9C,UAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;UAC/B,MAAM,GAAG,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAA;;;;;;;;AAQtC,UAAI,GAAG,IAAI,MAAM,GAAG,MAAM,EAAE;AAC1B,WAAG,GAAG,GAAG,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;AACxC,WAAG,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,EACd,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAA;OAChE,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,MAAM,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,EAAE;;AAEtD,WAAG,GAAG,GAAG,CAAA;OACV,MAAM;;AAEL,WAAG,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,CAAA;OACrD;;AAED,UAAI,MAAM,GAAG,MAAM,EAAE;;;AAGnB,YAAI,CAAC,OAAO,IAAI,MAAM,CAAA;AACtB,cAAM,GAAG,CAAC,CAAA;OACX,MAAM;;;AAGL,cAAM,IAAI,MAAM,CAAA;AAChB,iBAAS,IAAI,MAAM,CAAA;AACnB,mBAAW,EAAG,CAAA;AACd,YAAI,CAAC,OAAO,GAAG,CAAC,CAAA;OACjB;KACF;;AAED,QAAI,CAAC,aAAa,IAAI,IAAI,CAAC,UAAU,CAAA;AACrC,UAAM,CAAC,GAAG,CAAC,MAAM,KAAK,IAAI,CAAC,UAAU,CAAC,CAAA;;;AAGtC,QAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAA;AACtB,OAAG,GAAG,IAAI,CAAA;GACX;;;;AAID,MAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,CAAA;AAC9C,MAAI,IAAI,CAAC,OAAO,EAAE;;AAEhB,QAAI,CAAC,WAAW,GAAG,IAAI,CAAA;AACvB,QAAI,CAAC,SAAS,GAAG,KAAK,CAAA;AACtB,WAAM;GACP;;;;;;AAMD,MAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAA;AAC3B,MAAI,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE;AAC/B,QAAI,CAAC,KAAK,CAAC,EAAE;AACX,UAAI,IAAI,CAAC,OAAO,EAAE;AAChB,YAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAA;OACvD,MAAM;AACL,YAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAA;OACnC;KACF,MAAM;AACL,UAAI,MAAM,GAAG,IAAI,CAAC,aAAa;UAC3B,GAAG,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC;UACxB,SAAS,GAAG,CAAC,CAAA;AACjB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAG,EAAE;AAC3B,YAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACrB,MAAM,GAAG,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAA;AACtC,WAAG,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,CAAA;AACtC,YAAI,CAAC,OAAO,GAAG,CAAC,CAAA;AAChB,iBAAS,IAAI,MAAM,CAAA;AACnB,YAAI,CAAC,aAAa,IAAI,MAAM,CAAA;OAC7B;AACD,UAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAA;KACvB;;AAED,QAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAA;AACvB,QAAI,CAAC,aAAa,GAAG,CAAC,CAAA;AACtB,QAAI,CAAC,OAAO,GAAG,CAAC,CAAA;GACjB;;;;;AAKD,MAAI,IAAI,CAAC,UAAU,EAAE;;AAEnB,QAAI,CAAC,UAAU,GAAG,KAAK,CAAA;AACvB,QAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;GACnB;;AAED,MAAI,AAAC,IAAI,CAAC,aAAa,KAAK,CAAC,IAAK,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;;AAElE,QAAI,CAAC,WAAW,GAAG,IAAI,CAAA;AACvB,QAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;GACjB;;AAED,MAAI,CAAC,SAAS,GAAG,KAAK,CAAA;;;CAGvB,CAAA","file":"block-stream-compiled.js","sourcesContent":["// write data to it, and it'll emit data in 512 byte blocks.\n// if you .end() or .flush(), it'll emit whatever it's got,\n// padded with nulls to 512 bytes.\n\nmodule.exports = BlockStream\n\nvar Stream = require(\"stream\").Stream\n  , inherits = require(\"inherits\")\n  , assert = require(\"assert\").ok\n  , debug = process.env.DEBUG ? console.error : function () {}\n\nfunction BlockStream (size, opt) {\n  this.writable = this.readable = true\n  this._opt = opt || {}\n  this._chunkSize = size || 512\n  this._offset = 0\n  this._buffer = []\n  this._bufferLength = 0\n  if (this._opt.nopad) this._zeroes = false\n  else {\n    this._zeroes = new Buffer(this._chunkSize)\n    for (var i = 0; i < this._chunkSize; i ++) {\n      this._zeroes[i] = 0\n    }\n  }\n}\n\ninherits(BlockStream, Stream)\n\nBlockStream.prototype.write = function (c) {\n  // debug(\"   BS write\", c)\n  if (this._ended) throw new Error(\"BlockStream: write after end\")\n  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + \"\")\n  if (c.length) {\n    this._buffer.push(c)\n    this._bufferLength += c.length\n  }\n  // debug(\"pushed onto buffer\", this._bufferLength)\n  if (this._bufferLength >= this._chunkSize) {\n    if (this._paused) {\n      // debug(\"   BS paused, return false, need drain\")\n      this._needDrain = true\n      return false\n    }\n    this._emitChunk()\n  }\n  return true\n}\n\nBlockStream.prototype.pause = function () {\n  // debug(\"   BS pausing\")\n  this._paused = true\n}\n\nBlockStream.prototype.resume = function () {\n  // debug(\"   BS resume\")\n  this._paused = false\n  return this._emitChunk()\n}\n\nBlockStream.prototype.end = function (chunk) {\n  // debug(\"end\", chunk)\n  if (typeof chunk === \"function\") cb = chunk, chunk = null\n  if (chunk) this.write(chunk)\n  this._ended = true\n  this.flush()\n}\n\nBlockStream.prototype.flush = function () {\n  this._emitChunk(true)\n}\n\nBlockStream.prototype._emitChunk = function (flush) {\n  // debug(\"emitChunk flush=%j emitting=%j paused=%j\", flush, this._emitting, this._paused)\n\n  // emit a <chunkSize> chunk\n  if (flush && this._zeroes) {\n    // debug(\"    BS push zeroes\", this._bufferLength)\n    // push a chunk of zeroes\n    var padBytes = (this._bufferLength % this._chunkSize)\n    if (padBytes !== 0) padBytes = this._chunkSize - padBytes\n    if (padBytes > 0) {\n      // debug(\"padBytes\", padBytes, this._zeroes.slice(0, padBytes))\n      this._buffer.push(this._zeroes.slice(0, padBytes))\n      this._bufferLength += padBytes\n      // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)\n    }\n  }\n\n  if (this._emitting || this._paused) return\n  this._emitting = true\n\n  // debug(\"    BS entering loops\")\n  var bufferIndex = 0\n  while (this._bufferLength >= this._chunkSize &&\n         (flush || !this._paused)) {\n    // debug(\"     BS data emission loop\", this._bufferLength)\n\n    var out\n      , outOffset = 0\n      , outHas = this._chunkSize\n\n    while (outHas > 0 && (flush || !this._paused) ) {\n      // debug(\"    BS data inner emit loop\", this._bufferLength)\n      var cur = this._buffer[bufferIndex]\n        , curHas = cur.length - this._offset\n      // debug(\"cur=\", cur)\n      // debug(\"curHas=%j\", curHas)\n      // If it's not big enough to fill the whole thing, then we'll need\n      // to copy multiple buffers into one.  However, if it is big enough,\n      // then just slice out the part we want, to save unnecessary copying.\n      // Also, need to copy if we've already done some copying, since buffers\n      // can't be joined like cons strings.\n      if (out || curHas < outHas) {\n        out = out || new Buffer(this._chunkSize)\n        cur.copy(out, outOffset,\n                 this._offset, this._offset + Math.min(curHas, outHas))\n      } else if (cur.length === outHas && this._offset === 0) {\n        // shortcut -- cur is exactly long enough, and no offset.\n        out = cur\n      } else {\n        // slice out the piece of cur that we need.\n        out = cur.slice(this._offset, this._offset + outHas)\n      }\n\n      if (curHas > outHas) {\n        // means that the current buffer couldn't be completely output\n        // update this._offset to reflect how much WAS written\n        this._offset += outHas\n        outHas = 0\n      } else {\n        // output the entire current chunk.\n        // toss it away\n        outHas -= curHas\n        outOffset += curHas\n        bufferIndex ++\n        this._offset = 0\n      }\n    }\n\n    this._bufferLength -= this._chunkSize\n    assert(out.length === this._chunkSize)\n    // debug(\"emitting data\", out)\n    // debug(\"   BS emitting, paused=%j\", this._paused, this._bufferLength)\n    this.emit(\"data\", out)\n    out = null\n  }\n  // debug(\"    BS out of loops\", this._bufferLength)\n\n  // whatever is left, it's not enough to fill up a block, or we're paused\n  this._buffer = this._buffer.slice(bufferIndex)\n  if (this._paused) {\n    // debug(\"    BS paused, leaving\", this._bufferLength)\n    this._needsDrain = true\n    this._emitting = false\n    return\n  }\n\n  // if flushing, and not using null-padding, then need to emit the last\n  // chunk(s) sitting in the queue.  We know that it's not enough to\n  // fill up a whole block, because otherwise it would have been emitted\n  // above, but there may be some offset.\n  var l = this._buffer.length\n  if (flush && !this._zeroes && l) {\n    if (l === 1) {\n      if (this._offset) {\n        this.emit(\"data\", this._buffer[0].slice(this._offset))\n      } else {\n        this.emit(\"data\", this._buffer[0])\n      }\n    } else {\n      var outHas = this._bufferLength\n        , out = new Buffer(outHas)\n        , outOffset = 0\n      for (var i = 0; i < l; i ++) {\n        var cur = this._buffer[i]\n          , curHas = cur.length - this._offset\n        cur.copy(out, outOffset, this._offset)\n        this._offset = 0\n        outOffset += curHas\n        this._bufferLength -= curHas\n      }\n      this.emit(\"data\", out)\n    }\n    // truncate\n    this._buffer.length = 0\n    this._bufferLength = 0\n    this._offset = 0\n  }\n\n  // now either drained or ended\n  // debug(\"either draining, or ended\", this._bufferLength, this._ended)\n  // means that we've flushed out all that we can so far.\n  if (this._needDrain) {\n    // debug(\"emitting drain\", this._bufferLength)\n    this._needDrain = false\n    this.emit(\"drain\")\n  }\n\n  if ((this._bufferLength === 0) && this._ended && !this._endEmitted) {\n    // debug(\"emitting end\", this._bufferLength)\n    this._endEmitted = true\n    this.emit(\"end\")\n  }\n\n  this._emitting = false\n\n  // debug(\"    BS no longer emitting\", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)\n}\n"]}