{"version":3,"sources":["collect.js"],"names":[],"mappings":";;AAAA,MAAM,CAAC,OAAO,GAAG,OAAO,CAAA;;AAExB,SAAS,OAAO,CAAE,MAAM,EAAE;AACxB,MAAI,MAAM,CAAC,UAAU,EAAE,OAAM;;AAE7B,QAAM,CAAC,UAAU,GAAG,IAAI,CAAA;AACxB,QAAM,CAAC,KAAK,EAAE,CAAA;;AAEd,QAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;AACvB,QAAM,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;AACtB,MAAI,GAAG,GAAG,EAAE,CAAA;AACZ,WAAS,IAAI,CAAE,CAAC,EAAE;AAChB,QAAI,OAAO,CAAC,KAAK,QAAQ,EAAE,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,CAAA;AAC5C,QAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,EAAE,OAAM;AAC3C,OAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;GACZ;;AAED,QAAM,CAAC,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC,CAAA;AAC7B,MAAI,WAAW,GAAG,EAAE,CAAA;AACpB,WAAS,SAAS,CAAE,CAAC,EAAE;AACrB,WAAO,CAAC,CAAC,CAAC,CAAA;AACV,eAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;GACpB;;AAED,QAAM,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;AAC9B,WAAS,UAAU,CAAE,CAAC,EAAE;AACtB,KAAC,CAAC,KAAK,EAAE,CAAA;GACV;;;;;AAKD,QAAM,CAAC,IAAI,GAAG,CAAC,UAAU,IAAI,EAAE;AAC7B,WAAO,UAAU,IAAI,EAAE;;;;;AAKrB,UAAI,CAAC,GAAG,CAAC,CACR,CAAC,SAAS,YAAY,GAAI;AACzB,YAAI,KAAK,GAAG,WAAW,CAAC,CAAC,EAAE,CAAC,CAAA;;AAE5B,YAAI,CAAC,KAAK,EAAE,OAAO,MAAM,EAAE,CAAA;AAC3B,aAAK,CAAC,EAAE,CAAC,KAAK,EAAE,YAAY,CAAC,CAAA;AAC7B,YAAI,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA,KACpB,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAA;OACjC,CAAA,EAAG,CAAA;;AAEJ,eAAS,MAAM,GAAI;AACjB,cAAM,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,CAAA;AACzC,cAAM,CAAC,cAAc,CAAC,MAAM,EAAE,IAAI,CAAC,CAAA;AACnC,cAAM,CAAC,cAAc,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;;AAElC,cAAM,CAAC,IAAI,GAAG,IAAI,CAAA;AAClB,YAAI,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;AAE3B,WAAG,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;AACvB,cAAI,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAA,KACxB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;SACxB,CAAC,CAAA;;AAEF,cAAM,CAAC,MAAM,EAAE,CAAA;OAChB;;AAED,aAAO,IAAI,CAAA;KACZ,CAAA;GACF,CAAA,CAAE,MAAM,CAAC,IAAI,CAAC,CAAA;CAChB","file":"collect-compiled.js","sourcesContent":["module.exports = collect\n\nfunction collect (stream) {\n  if (stream._collected) return\n\n  stream._collected = true\n  stream.pause()\n\n  stream.on('data', save)\n  stream.on('end', save)\n  var buf = []\n  function save (b) {\n    if (typeof b === 'string') b = new Buffer(b)\n    if (Buffer.isBuffer(b) && !b.length) return\n    buf.push(b)\n  }\n\n  stream.on('entry', saveEntry)\n  var entryBuffer = []\n  function saveEntry (e) {\n    collect(e)\n    entryBuffer.push(e)\n  }\n\n  stream.on('proxy', proxyPause)\n  function proxyPause (p) {\n    p.pause()\n  }\n\n  // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n  stream.pipe = (function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0\n      ;(function unblockEntry () {\n        var entry = entryBuffer[e++]\n        // console.error(\" ==== unblock entry\", entry && entry.path)\n        if (!entry) return resume()\n        entry.on('end', unblockEntry)\n        if (dest) dest.add(entry)\n        else stream.emit('entry', entry)\n      })()\n\n      function resume () {\n        stream.removeListener('entry', saveEntry)\n        stream.removeListener('data', save)\n        stream.removeListener('end', save)\n\n        stream.pipe = orig\n        if (dest) stream.pipe(dest)\n\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b)\n          else stream.emit('end')\n        })\n\n        stream.resume()\n      }\n\n      return dest\n    }\n  })(stream.pipe)\n}\n"]}