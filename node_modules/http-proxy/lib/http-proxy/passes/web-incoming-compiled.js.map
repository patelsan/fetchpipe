{"version":3,"sources":["web-incoming.js"],"names":[],"mappings":"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","file":"web-incoming-compiled.js","sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    web_o  = require('./web-outgoing'),\n    common = require('../common'),\n    passes = exports;\n\nweb_o = Object.keys(web_o).map(function(pass) {\n  return web_o[pass];\n});\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n[ // <--\n\n  /**\n   * Sets `content-length` to '0' if request is of DELETE type.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function deleteLength(req, res, options) {\n    if((req.method === 'DELETE' || req.method === 'OPTIONS')\n       && !req.headers['content-length']) {\n      req.headers['content-length'] = '0';\n    }\n  },\n\n  /**\n   * Sets timeout in request socket if it was specified in options.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function timeout(req, res, options) {\n    if(options.timeout) {\n      req.socket.setTimeout(options.timeout);\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function XHeaders(req, res, options) {\n    if(!options.xfwd) return;\n\n    var encrypted = req.isSpdy || common.hasEncryptedConnection(req);\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: encrypted ? 'https' : 'http'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. If `forward` is enabled fires up\n   * a ForwardStream, same happens for ProxyStream. The request\n   * just dies otherwise.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function stream(req, res, options, _, server, clb) {\n\n    // And we begin!\n    server.emit('start', req, res, options.target)\n    if(options.forward) {\n      // If forward enable, so just pipe the request\n      var forwardReq = (options.forward.protocol === 'https:' ? https : http).request(\n        common.setupOutgoing(options.ssl || {}, options, req, 'forward')\n      );\n      (options.buffer || req).pipe(forwardReq);\n      if(!options.target) { return res.end(); }\n    }\n\n    // Request initalization\n    var proxyReq = (options.target.protocol === 'https:' ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    proxyReq.on('socket', function(socket) {\n      if(server) { server.emit('proxyReq', proxyReq, req, res, options); }\n    });\n\n    // allow outgoing socket to timeout so that we could\n    // show an error page at the initial request\n    if(options.proxyTimeout) {\n      proxyReq.setTimeout(options.proxyTimeout, function() {\n         proxyReq.abort();\n      });\n    }\n\n    // Ensure we abort proxy if request is aborted\n    req.on('aborted', function () {\n      proxyReq.abort();\n    });\n\n    // Handle errors on incoming request as well as it makes sense to\n    req.on('error', proxyError);\n\n    // Error Handler\n    proxyReq.on('error', proxyError);\n\n    function proxyError (err){\n      if (clb) {\n        clb(err, req, res, options.target);\n      } else {\n        server.emit('error', err, req, res, options.target);\n      }\n    }\n\n    (options.buffer || req).pipe(proxyReq);\n\n    proxyReq.on('response', function(proxyRes) {\n      if(server) { server.emit('proxyRes', proxyRes, req, res); }\n      for(var i=0; i < web_o.length; i++) {\n        if(web_o[i](req, res, proxyRes, options)) { break; }\n      }\n\n      // Allow us to listen when the proxy has completed\n      proxyRes.on('end', function () {\n        server.emit('end', req, res, proxyRes);\n      });\n\n      proxyRes.pipe(res);\n    });\n\n    //proxyReq.end();\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]}