{"version":3,"sources":["ws-incoming.js"],"names":[],"mappings":"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","file":"ws-incoming-compiled.js","sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    common = require('../common'),\n    passes = exports;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\nvar passes = exports;\n\n[\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  function checkMethodAndHeader (req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(\n        Object.keys(proxyRes.headers).reduce(function (head, key) {\n          var value = proxyRes.headers[key];\n\n          if (!Array.isArray(value)) {\n            head.push(key + ': ' + value);\n            return head;\n          }\n\n          for (var i = 0; i < value.length; i++) {\n            head.push(key + ': ' + value[i]);\n          }\n          return head;\n        }, ['HTTP/1.1 101 Switching Protocols'])\n        .join('\\r\\n') + '\\r\\n\\r\\n'\n      );\n\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n\n] // <--\n  .forEach(function(func) {\n    passes[func.name] = func;\n  });\n"]}