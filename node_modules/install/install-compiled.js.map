{"version":3,"sources":["install.js"],"names":[],"mappings":"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","file":"install-compiled.js","sourcesContent":["(function(global, undefined) {\n    // Defining the `install` function more than once leads to mayhem, so\n    // return immedately if a property called `install` is already defined on\n    // the global object.\n    if (global.install)\n        return;\n\n    // The `installed` object maps absolute module identifiers to module\n    // definitions available for requirement.\n    var installed = {};\n\n    // I make frequent use of `hasOwn.call` to test for the presence of object\n    // properties without traversing the prototype chain.\n    var hasOwn = installed.hasOwnProperty;\n\n    // Anonymous modules are pushed onto a queue so that (when ready) they can\n    // be executed in order of installation.\n    var qhead = {};\n    var qtail = qhead;\n\n    // Define the `install` function globally.\n    global.install = function(id, module) {\n        // To install a named module, pass an absolute module identifier\n        // string followed by a module definition. Note that named modules are\n        // not evaluated until they are required for the first time.\n        if (typeof id === \"string\" && module) {\n            if (!hasOwn.call(installed, id)) {\n                installed[module.id = id] = module;\n                flushQueue();\n            }\n        // To install an anonymous module, pass a module definition without an\n        // identifier. Anonymous modules are executed in order of\n        // installation, as soon as their requirements have been installed.\n        } else if (id && typeof id.call === \"function\") {\n            qtail = qtail.next = { module: id };\n            if (qhead.next === qtail)\n                flushQueue();\n        }\n    };\n\n    // The `require` function takes an absolute module identifier and returns\n    // the `exports` object defined by that module. An error is thrown if no\n    // module with the given identifier is installed.\n    function require(moduleId) {\n        if (hasOwn.call(installed, moduleId)) {\n            var module = installed[moduleId];\n            if (!hasOwn.call(module, \"exports\")) {\n                // Each module receives a version of `require` that knows how\n                // to `absolutize` relative module identifiers with respect to\n                // `moduleId`.\n                module.call(global, function(id) {\n                    return require(absolutize(id, moduleId));\n                }, module.exports = {}, module);\n            }\n            // Note that `module.exports` may be redefined during evaluation\n            // of the module.\n            return module.exports;\n        }\n        // Since modules are evaluated only after all their requirements have\n        // been installed, this error generally means that `require` was\n        // called with an identifier that was not seen (or was not understood)\n        // by the dependency scanner.\n        throw new Error('module \"' + moduleId + '\" not installed');\n    }\n\n    // Given two module identifiers `id` and `baseId`, the `absolutize`\n    // function returns the absolute form of `id`, as if `id` were required\n    // from a module with the identifier `baseId`. For more information about\n    // relative identifiers, refer to the\n    // [spec](http://wiki.commonjs.org/wiki/Modules/1.1#Module_Identifiers).\n    var pathNormExp = /\\/(\\.?|[^\\/]+\\/\\.\\.)\\//;\n    function absolutize(id, baseId) {\n        if (id.charAt(0) === \".\") {\n            // Note: if `baseId` is omitted, then `\"/undefined/../\" + id` will\n            // be the starting point for normalization, which works just fine!\n            id = \"/\" + baseId + \"/../\" + id;\n            while (id != (baseId = id.replace(pathNormExp, \"/\")))\n                id = baseId;\n            id = id.replace(/^\\//, \"\");\n        }\n        return id;\n    }\n\n    // The `flushQueue` function attempts to evaluate the oldest module in the\n    // queue, provided all of its dependencies have been installed. This\n    // provision is important because it ensures that the module can call\n    // `require` without fear of missing dependencies.\n    function flushQueue() {\n        var next = qhead.next, module;\n        if (next && !flushing && ready(module = next.module)) {\n            flushing = qhead = next;\n            // Module evaluation might throw an exception, so we need to\n            // schedule the next call to `flushQueue` before invoking\n            // `module.call`. The `setTimeout` function allows the stack to\n            // unwind before flushing resumes, so that the browser has a chance\n            // to report exceptions and/or handle other events.\n            global.setTimeout(resume, 0);\n            module.call(global, require);\n            flushing = undefined;\n        }\n    }\n\n    // If `install` is called during the evaluation of a queued module,\n    // `flushQueue` could be invoked recursively. To prevent double evaluation,\n    // `flushQueue` sets `flushing` to a truthy value before it evaluates a\n    // module and refuses to evaluate any modules if `flushing` is truthy\n    // already.\n    var flushing;\n\n    // Since `resume` is only ever invoked from `setTimeout`, there is no risk\n    // that `flushQueue` is already executing, so it is safe to clear the\n    // `flushing` flag unconditionally.\n    function resume() {\n        flushing = undefined;\n        flushQueue();\n    }\n\n    // To be recognized as dependencies, calls to `require` must use string\n    // literal identifiers.\n    var requireExp = /\\brequire\\(['\"]([^'\"]+)['\"]\\)/g;\n\n    // A module is `ready` to be evaluated if\n    //\n    //   1. it has an `.exports` property (indicating that it has already begun to be evaluated) or\n    //   1. all of its direct dependencies are installed and `ready` to be evaluated.\n    //\n    // Note that the above definition is recursive.\n    function ready(module) {\n        var deps, code, match, id, result = true;\n\n        if (!module.seen &&\n            !hasOwn.call(module, \"exports\"))\n        {\n            // Here's a little secret: module definitions don't have to be\n            // functions, as long as they have a suitable `.toString` and\n            // `.call` methods. If you have a really long module that you\n            // don't want to waste time scanning, just override its\n            // `.toString` function to return something equivalent (with\n            // regard to dependencies) but shorter.\n            deps = module.deps;\n            if (!deps) {\n                code = module + \"\";\n                deps = module.deps = {};\n                requireExp.lastIndex = 0;\n                while ((match = requireExp.exec(code)))\n                    deps[absolutize(match[1], module.id)] = true;\n            }\n\n            // There may be cycles in the dependency graph, so we must be\n            // careful that the recursion always terminates. Each module we\n            // check is temporarily marked as `.seen` before its dependencies\n            // are traversed, so that if we encounter the same module again we\n            // can immediately return `true`.\n            module.seen = true;\n\n            for (id in deps) {\n                if (hasOwn.call(deps, id)) {\n                    // Once a dependency is determined to be satisfied, we\n                    // remove its identifier from `module.deps`, so that we\n                    // can avoid considering it again if `ready` is called\n                    // multiple times.\n                    if (hasOwn.call(installed, id) && ready(installed[id])) {\n                        delete deps[id];\n                    // If any dependency is missing or not `ready`, then the\n                    // current module is not yet `ready`. The `break` is not\n                    // strictly necessary here, but immediately terminating\n                    // the loop postpones work that can be done later.\n                    } else {\n                        result = false;\n                        break;\n                    }\n                }\n            }\n\n            // Ordinarily I would be more paranoid about always resetting\n            // `module.seen` to `false`, but if you thoroughly examine the code\n            // above, you'll find that the only real threat of exceptions comes\n            // from evaluating `code = module + \"\"` in a recursive call to\n            // `ready`. So if you decide to override the `.toString` method of a\n            // module for performance reasons, get it right.\n            module.seen = false;\n        }\n\n        return result;\n    }\n\n// The most reliable way to get the global object:\n// [http://stackoverflow.com/a/3277192/128454](http://stackoverflow.com/a/3277192/128454)\n}(Function(\"return this\")()));\n"]}