{"version":3,"sources":["multiprocess.js"],"names":[],"mappings":"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","file":"multiprocess-compiled.js","sourcesContent":["\"use strict\";\nvar log4js = require('../log4js')\n, net = require('net')\n, END_MSG = '__LOG4JS__';\n\n/**\n * Creates a server, listening on config.loggerPort, config.loggerHost.\n * Output goes to config.actualAppender (config.appender is used to\n * set up that appender).\n */\nfunction logServer(config) {\n  \n  /**\n   * Takes a utf-8 string, returns an object with\n   * the correct log properties.\n   */\n  function deserializeLoggingEvent(clientSocket, msg) {\n    var loggingEvent;\n    try {\n      loggingEvent = JSON.parse(msg);\n      loggingEvent.startTime = new Date(loggingEvent.startTime);\n      loggingEvent.level = log4js.levels.toLevel(loggingEvent.level.levelStr);\n    } catch (e) {\n      // JSON.parse failed, just log the contents probably a naughty.\n      loggingEvent = {\n        startTime: new Date(),\n        categoryName: 'log4js',\n        level: log4js.levels.ERROR,\n        data: [ 'Unable to parse log:', msg ]\n      };\n    }\n\n    loggingEvent.remoteAddress = clientSocket.remoteAddress;\n    loggingEvent.remotePort = clientSocket.remotePort;\n    \n    return loggingEvent;\n  }\n  \n  var actualAppender = config.actualAppender,\n  server = net.createServer(function serverCreated(clientSocket) {\n    clientSocket.setEncoding('utf8');\n    var logMessage = '';\n    \n    function logTheMessage(msg) {\n      if (logMessage.length > 0) {\n        actualAppender(deserializeLoggingEvent(clientSocket, msg));\n      }\n    }\n    \n    function chunkReceived(chunk) {\n      var event;\n      logMessage += chunk || '';\n      if (logMessage.indexOf(END_MSG) > -1) {\n        event = logMessage.substring(0, logMessage.indexOf(END_MSG));\n        logTheMessage(event);\n        logMessage = logMessage.substring(event.length + END_MSG.length) || '';\n        //check for more, maybe it was a big chunk\n        chunkReceived();\n      }\n    }\n    \n    clientSocket.on('data', chunkReceived);\n    clientSocket.on('end', chunkReceived);\n  });\n  \n  server.listen(config.loggerPort || 5000, config.loggerHost || 'localhost');\n  \n  return actualAppender;\n}\n\nfunction workerAppender(config) {\n  var canWrite = false,\n  buffer = [],\n  socket;\n  \n  createSocket();\n  \n  function createSocket() {\n    socket = net.createConnection(config.loggerPort || 5000, config.loggerHost || 'localhost');\n    socket.on('connect', function() {\n      emptyBuffer();\n      canWrite = true;\n    });\n    socket.on('timeout', socket.end.bind(socket));\n    //don't bother listening for 'error', 'close' gets called after that anyway\n    socket.on('close', createSocket);\n  }\n  \n  function emptyBuffer() {\n    var evt;\n    while ((evt = buffer.shift())) {\n      write(evt);\n    }\n  }\n  \n  function write(loggingEvent) {\n\t// JSON.stringify(new Error('test')) returns {}, which is not really useful for us.\n\t// The following allows us to serialize errors correctly.\n\tif (loggingEvent && loggingEvent.stack && JSON.stringify(loggingEvent) === '{}') { // Validate that we really are in this case\n\t\tloggingEvent = {stack : loggingEvent.stack};\n\t}\n    socket.write(JSON.stringify(loggingEvent), 'utf8');\n    socket.write(END_MSG, 'utf8');\n  }\n  \n  return function log(loggingEvent) {\n    if (canWrite) {\n      write(loggingEvent);\n    } else {\n      buffer.push(loggingEvent);\n    }\n  };\n}\n\nfunction createAppender(config) {\n  if (config.mode === 'master') {\n    return logServer(config);\n  } else {\n    return workerAppender(config);\n  }\n}\n\nfunction configure(config, options) {\n  var actualAppender;\n  if (config.appender && config.mode === 'master') {\n    log4js.loadAppender(config.appender.type);\n    actualAppender = log4js.appenderMakers[config.appender.type](config.appender, options);\n    config.actualAppender = actualAppender;\n  }\n  return createAppender(config);\n}\n\nexports.appender = createAppender;\nexports.configure = configure;\n"]}