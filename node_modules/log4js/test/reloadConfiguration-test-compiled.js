"use strict";
var vows = require('vows'),
    assert = require('assert'),
    sandbox = require('sandboxed-module');

function setupConsoleTest() {
  var fakeConsole = {},
      logEvents = [],
      log4js;

  ['trace', 'debug', 'log', 'info', 'warn', 'error'].forEach(function (fn) {
    fakeConsole[fn] = function () {
      throw new Error("this should not be called.");
    };
  });

  log4js = sandbox.require('../lib/log4js', {
    globals: {
      console: fakeConsole
    }
  });

  log4js.clearAppenders();
  log4js.addAppender(function (evt) {
    logEvents.push(evt);
  });

  return { log4js: log4js, logEvents: logEvents, fakeConsole: fakeConsole };
}

vows.describe('reload configuration').addBatch({
  'with config file changing': {
    topic: function topic() {
      var pathsChecked = [],
          logEvents = [],
          logger,
          modulePath = 'path/to/log4js.json',
          fakeFS = {
        lastMtime: Date.now(),
        config: {
          appenders: [{ type: 'console', layout: { type: 'messagePassThrough' } }],
          levels: { 'a-test': 'INFO' }
        },
        readFileSync: function readFileSync(file, encoding) {
          assert.equal(file, modulePath);
          assert.equal(encoding, 'utf8');
          return JSON.stringify(fakeFS.config);
        },
        statSync: function statSync(path) {
          pathsChecked.push(path);
          if (path === modulePath) {
            fakeFS.lastMtime += 1;
            return { mtime: new Date(fakeFS.lastMtime) };
          } else {
            throw new Error("no such file");
          }
        }
      },
          fakeConsole = {
        'name': 'console',
        'appender': function appender() {
          return function (evt) {
            logEvents.push(evt);
          };
        },
        'configure': function configure(config) {
          return fakeConsole.appender();
        }
      },
          setIntervalCallback,
          fakeSetInterval = function fakeSetInterval(cb, timeout) {
        setIntervalCallback = cb;
      },
          log4js = sandbox.require('../lib/log4js', {
        requires: {
          'fs': fakeFS,
          './appenders/console': fakeConsole
        },
        globals: {
          'console': fakeConsole,
          'setInterval': fakeSetInterval
        }
      });

      log4js.configure('path/to/log4js.json', { reloadSecs: 30 });
      logger = log4js.getLogger('a-test');
      logger.info("info1");
      logger.debug("debug2 - should be ignored");
      fakeFS.config.levels['a-test'] = "DEBUG";
      setIntervalCallback();
      logger.info("info3");
      logger.debug("debug4");

      return logEvents;
    },
    'should configure log4js from first log4js.json found': function shouldConfigureLog4jsFromFirstLog4jsJsonFound(logEvents) {
      assert.equal(logEvents[0].data[0], 'info1');
      assert.equal(logEvents[1].data[0], 'info3');
      assert.equal(logEvents[2].data[0], 'debug4');
      assert.equal(logEvents.length, 3);
    }
  },

  'with config file staying the same': {
    topic: function topic() {
      var pathsChecked = [],
          fileRead = 0,
          logEvents = [],
          logger,
          modulePath = require('path').normalize(__dirname + '/../lib/log4js.json'),
          mtime = new Date(),
          fakeFS = {
        config: {
          appenders: [{ type: 'console', layout: { type: 'messagePassThrough' } }],
          levels: { 'a-test': 'INFO' }
        },
        readFileSync: function readFileSync(file, encoding) {
          fileRead += 1;
          assert.isString(file);
          assert.equal(file, modulePath);
          assert.equal(encoding, 'utf8');
          return JSON.stringify(fakeFS.config);
        },
        statSync: function statSync(path) {
          pathsChecked.push(path);
          if (path === modulePath) {
            return { mtime: mtime };
          } else {
            throw new Error("no such file");
          }
        }
      },
          fakeConsole = {
        'name': 'console',
        'appender': function appender() {
          return function (evt) {
            logEvents.push(evt);
          };
        },
        'configure': function configure(config) {
          return fakeConsole.appender();
        }
      },
          setIntervalCallback,
          fakeSetInterval = function fakeSetInterval(cb, timeout) {
        setIntervalCallback = cb;
      },
          log4js = sandbox.require('../lib/log4js', {
        requires: {
          'fs': fakeFS,
          './appenders/console': fakeConsole
        },
        globals: {
          'console': fakeConsole,
          'setInterval': fakeSetInterval
        }
      });

      log4js.configure(modulePath, { reloadSecs: 3 });
      logger = log4js.getLogger('a-test');
      logger.info("info1");
      logger.debug("debug2 - should be ignored");
      setIntervalCallback();
      logger.info("info3");
      logger.debug("debug4");

      return [pathsChecked, logEvents, modulePath, fileRead];
    },
    'should only read the configuration file once': function shouldOnlyReadTheConfigurationFileOnce(args) {
      var fileRead = args[3];
      assert.equal(fileRead, 1);
    },
    'should configure log4js from first log4js.json found': function shouldConfigureLog4jsFromFirstLog4jsJsonFound(args) {
      var logEvents = args[1];
      assert.equal(logEvents.length, 2);
      assert.equal(logEvents[0].data[0], 'info1');
      assert.equal(logEvents[1].data[0], 'info3');
    }
  },

  'when config file is removed': {
    topic: function topic() {
      var pathsChecked = [],
          fileRead = 0,
          logEvents = [],
          logger,
          modulePath = require('path').normalize(__dirname + '/../lib/log4js.json'),
          mtime = new Date(),
          fakeFS = {
        config: {
          appenders: [{ type: 'console', layout: { type: 'messagePassThrough' } }],
          levels: { 'a-test': 'INFO' }
        },
        readFileSync: function readFileSync(file, encoding) {
          fileRead += 1;
          assert.isString(file);
          assert.equal(file, modulePath);
          assert.equal(encoding, 'utf8');
          return JSON.stringify(fakeFS.config);
        },
        statSync: function statSync(path) {
          this.statSync = function () {
            throw new Error("no such file");
          };
          return { mtime: new Date() };
        }
      },
          fakeConsole = {
        'name': 'console',
        'appender': function appender() {
          return function (evt) {
            logEvents.push(evt);
          };
        },
        'configure': function configure(config) {
          return fakeConsole.appender();
        }
      },
          setIntervalCallback,
          fakeSetInterval = function fakeSetInterval(cb, timeout) {
        setIntervalCallback = cb;
      },
          log4js = sandbox.require('../lib/log4js', {
        requires: {
          'fs': fakeFS,
          './appenders/console': fakeConsole
        },
        globals: {
          'console': fakeConsole,
          'setInterval': fakeSetInterval
        }
      });

      log4js.configure(modulePath, { reloadSecs: 3 });
      logger = log4js.getLogger('a-test');
      logger.info("info1");
      logger.debug("debug2 - should be ignored");
      setIntervalCallback();
      logger.info("info3");
      logger.debug("debug4");

      return [pathsChecked, logEvents, modulePath, fileRead];
    },
    'should only read the configuration file once': function shouldOnlyReadTheConfigurationFileOnce(args) {
      var fileRead = args[3];
      assert.equal(fileRead, 1);
    },
    'should not clear configuration when config file not found': function shouldNotClearConfigurationWhenConfigFileNotFound(args) {
      var logEvents = args[1];
      assert.equal(logEvents.length, 3);
      assert.equal(logEvents[0].data[0], 'info1');
      assert.equal(logEvents[1].level.toString(), 'WARN');
      assert.include(logEvents[1].data[0], 'Failed to load configuration file');
      assert.equal(logEvents[2].data[0], 'info3');
    }
  },

  'when passed an object': {
    topic: function topic() {
      var test = setupConsoleTest();
      test.log4js.configure({}, { reloadSecs: 30 });
      return test.logEvents;
    },
    'should log a warning': function shouldLogAWarning(events) {
      assert.equal(events[0].level.toString(), 'WARN');
      assert.equal(events[0].data[0], 'Ignoring configuration reload parameter for "object" configuration.');
    }
  },

  'when called twice with reload options': {
    topic: function topic() {
      var modulePath = require('path').normalize(__dirname + '/../lib/log4js.json'),
          fakeFS = {
        readFileSync: function readFileSync(file, encoding) {
          return JSON.stringify({});
        },
        statSync: function statSync(path) {
          return { mtime: new Date() };
        }
      },
          fakeConsole = {
        'name': 'console',
        'appender': function appender() {
          return function (evt) {};
        },
        'configure': function configure(config) {
          return fakeConsole.appender();
        }
      },
          setIntervalCallback,
          intervalCleared = false,
          clearedId,
          fakeSetInterval = function fakeSetInterval(cb, timeout) {
        setIntervalCallback = cb;
        return 1234;
      },
          log4js = sandbox.require('../lib/log4js', {
        requires: {
          'fs': fakeFS,
          './appenders/console': fakeConsole
        },
        globals: {
          'console': fakeConsole,
          'setInterval': fakeSetInterval,
          'clearInterval': function clearInterval(interval) {
            intervalCleared = true;
            clearedId = interval;
          }
        }
      });

      log4js.configure(modulePath, { reloadSecs: 3 });
      log4js.configure(modulePath, { reloadSecs: 15 });

      return { cleared: intervalCleared, id: clearedId };
    },
    'should clear the previous interval': function shouldClearThePreviousInterval(result) {
      assert.isTrue(result.cleared);
      assert.equal(result.id, 1234);
    }
  }
}).exportTo(module);

//# sourceMappingURL=reloadConfiguration-test-compiled.js.map