{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar iconvEncodingMessageRegExp = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder(encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!iconvEncodingMessageRegExp.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', {\n      encoding: encoding\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody(stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor(resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead(err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt(stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Make a serializable error object.\n *\n * To create serializable errors you must re-set message so\n * that it is enumerable and you must re configure the type\n * property so that is writable and enumerable.\n *\n * @param {number} status\n * @param {string} message\n * @param {string} type\n * @param {object} props\n * @private\n */\n\nfunction createError(status, message, type, props) {\n  var error = new Error()\n\n  // capture stack trace\n  Error.captureStackTrace(error, createError)\n\n  // set free-form properties\n  for (var prop in props) {\n    error[prop] = props[prop]\n  }\n\n  // set message\n  error.message = message\n\n  // set status\n  error.status = status\n  error.statusCode = status\n\n  // set type\n  Object.defineProperty(error, 'type', {\n    value: type,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n\n  return error\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream(stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', 'entity.too.large', {\n      expected: length,\n      length: length,\n      limit: limit\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done() {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback() {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted() {\n    if (complete) return\n\n    done(createError(400, 'request aborted', 'request.aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received\n    }))\n  }\n\n  function onData(chunk) {\n    if (complete) return\n\n    received += chunk.length\n    decoder\n      ? buffer += decoder.write(chunk)\n      : buffer.push(chunk)\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', 'entity.too.large', {\n        limit: limit,\n        received: received\n      }))\n    }\n  }\n\n  function onEnd(err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', 'request.size.invalid', {\n        expected: length,\n        length: length,\n        received: received\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      cleanup()\n      done(null, string)\n    }\n  }\n\n  function cleanup() {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n"]}