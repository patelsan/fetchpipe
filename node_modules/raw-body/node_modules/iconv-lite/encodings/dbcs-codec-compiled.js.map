{"version":3,"sources":["dbcs-codec.js"],"names":[],"mappings":"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","file":"dbcs-codec-compiled.js","sourcesContent":["\"use strict\"\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), \n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = new Buffer(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = new Buffer(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = new Buffer(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = new Buffer(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"]}