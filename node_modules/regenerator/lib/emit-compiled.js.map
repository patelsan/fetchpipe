{"version":3,"sources":["emit.js"],"names":[],"mappings":"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","file":"emit-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nvar assert = require(\"assert\");\nvar types = require(\"recast\").types;\nvar isArray = types.builtInTypes.array;\nvar b = types.builders;\nvar n = types.namedTypes;\nvar leap = require(\"./leap\");\nvar meta = require(\"./meta\");\nvar util = require(\"./util\");\nvar runtimeProperty = util.runtimeProperty;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n  n.Identifier.assert(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  Object.defineProperties(this, {\n    // In order to make sure the context object does not collide with\n    // anything in the local scope, we might have to rename it, so we\n    // refer to it symbolically instead of just assuming that it will be\n    // called \"context\".\n    contextId: { value: contextId },\n\n    // An append-only list of Statements that grows each time this.emit is\n    // called.\n    listing: { value: [] },\n\n    // A sparse array whose keys correspond to locations in this.listing\n    // that have been marked as branch/jump targets.\n    marked: { value: [true] },\n\n    // The last location will be marked when this.getDispatchLoop is\n    // called.\n    finalLoc: { value: loc() },\n\n    // A list of all leap.TryEntry statements emitted.\n    tryEntries: { value: [] }\n  });\n\n  // The .leapManager property needs to be defined by a separate\n  // defineProperties call so that .finalLoc will be visible to the\n  // leap.LeapManager constructor.\n  Object.defineProperties(this, {\n    // Each time we evaluate the body of a loop, we tell this.leapManager\n    // to enter a nested loop context that determines the meaning of break\n    // and continue statements therein.\n    leapManager: { value: new leap.LeapManager(this) }\n  });\n}\n\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nfunction loc() {\n  return b.literal(-1);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function(loc) {\n  n.Literal.assert(loc);\n  var index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function(node) {\n  if (n.Expression.check(node))\n    node = b.expressionStatement(node);\n  n.Statement.assert(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function(lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function(lhs, rhs) {\n  return b.expressionStatement(\n    b.assignmentExpression(\"=\", lhs, rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function(name, computed) {\n  return b.memberExpression(\n    this.contextId,\n    computed ? b.literal(name) : b.identifier(name),\n    !!computed\n  );\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function(rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function(valuePath) {\n  n.Expression.assert(valuePath.value);\n\n  this.emitAssign(\n    this.contextProperty(\"rval\"),\n    this.explodeExpression(valuePath)\n  );\n};\n\nEp.clearPendingException = function(tryLoc, assignee) {\n  n.Literal.assert(tryLoc);\n\n  var catchCall = b.callExpression(\n    this.contextProperty(\"catch\", true),\n    [tryLoc]\n  );\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function(toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(b.breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function(test, toLoc) {\n  n.Expression.assert(test);\n  n.Literal.assert(toLoc);\n\n  this.emit(b.ifStatement(\n    test,\n    b.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      b.breakStatement()\n    ])\n  ));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function(test, toLoc) {\n  n.Expression.assert(test);\n  n.Literal.assert(toLoc);\n\n  var negatedTest;\n  if (n.UnaryExpression.check(test) &&\n      test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = b.unaryExpression(\"!\", test);\n  }\n\n  this.emit(b.ifStatement(\n    negatedTest,\n    b.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      b.breakStatement()\n    ])\n  ));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function() {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function(id) {\n  return b.functionExpression(\n    id || null/*Anonymous*/,\n    [this.contextId],\n    b.blockStatement([this.getDispatchLoop()]),\n    false, // Not a generator anymore!\n    false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function() {\n  var self = this;\n  var cases = [];\n  var current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  var alreadyEnded = false;\n\n  self.listing.forEach(function(stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(b.switchCase(\n        b.literal(i),\n        current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (isSwitchCaseEnder(stmt))\n        alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(\n    b.switchCase(this.finalLoc, [\n      // Intentionally fall through to the \"end\" case...\n    ]),\n\n    // So that the runtime can jump to the final location without having\n    // to know its offset, we provide the \"end\" case as a synonym.\n    b.switchCase(b.literal(\"end\"), [\n      // This will check/clear both context.thrown and context.rval.\n      b.returnStatement(\n        b.callExpression(this.contextProperty(\"stop\"), [])\n      )\n    ])\n  );\n\n  return b.whileStatement(\n    b.literal(1),\n    b.switchStatement(\n      b.assignmentExpression(\n        \"=\",\n        this.contextProperty(\"prev\"),\n        this.contextProperty(\"next\")\n      ),\n      cases\n    )\n  );\n};\n\n// See comment above re: alreadyEnded.\nfunction isSwitchCaseEnder(stmt) {\n  return n.BreakStatement.check(stmt)\n      || n.ContinueStatement.check(stmt)\n      || n.ReturnStatement.check(stmt)\n      || n.ThrowStatement.check(stmt);\n}\n\nEp.getTryLocsList = function() {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  var lastLocValue = 0;\n\n  return b.arrayExpression(\n    this.tryEntries.map(function(tryEntry) {\n      var thisLocValue = tryEntry.firstLoc.value;\n      assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n\n      var ce = tryEntry.catchEntry;\n      var fe = tryEntry.finallyEntry;\n\n      var locs = [\n        tryEntry.firstLoc,\n        // The null here makes a hole in the array.\n        ce ? ce.firstLoc : null\n      ];\n\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n\n      return b.arrayExpression(locs);\n    })\n  );\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function(path, ignoreResult) {\n  assert.ok(path instanceof types.NodePath);\n\n  var node = path.value;\n  var self = this;\n\n  n.Node.assert(node);\n\n  if (n.Statement.check(node))\n    return self.explodeStatement(path);\n\n  if (n.Expression.check(node))\n    return self.explodeExpression(path, ignoreResult);\n\n  if (n.Declaration.check(node))\n    throw getDeclError(node);\n\n  switch (node.type) {\n  case \"Program\":\n    return path.get(\"body\").map(\n      self.explodeStatement,\n      self\n    );\n\n  case \"VariableDeclarator\":\n    throw getDeclError(node);\n\n  // These node types should be handled by their parent nodes\n  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n  case \"Property\":\n  case \"SwitchCase\":\n  case \"CatchClause\":\n    throw new Error(\n      node.type + \" nodes should be handled by their parents\");\n\n  default:\n    throw new Error(\n      \"unknown Node of type \" +\n        JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n    \"assignments before the Exploder began its work: \" +\n    JSON.stringify(node));\n}\n\nEp.explodeStatement = function(path, labelId) {\n  assert.ok(path instanceof types.NodePath);\n\n  var stmt = path.value;\n  var self = this;\n\n  n.Statement.assert(stmt);\n\n  if (labelId) {\n    n.Identifier.assert(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (n.BlockStatement.check(stmt)) {\n    return path.get(\"body\").each(\n      self.explodeStatement,\n      self\n    );\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n  case \"ExpressionStatement\":\n    self.explodeExpression(path.get(\"expression\"), true);\n    break;\n\n  case \"LabeledStatement\":\n    var after = loc();\n\n    // Did you know you can break from any labeled block statement or\n    // control structure? Well, you can! Note: when a labeled loop is\n    // encountered, the leap.LabeledEntry created here will immediately\n    // enclose a leap.LoopEntry on the leap manager's stack, and both\n    // entries will have the same label. Though this works just fine, it\n    // may seem a bit redundant. In theory, we could check here to\n    // determine if stmt knows how to handle its own label; for example,\n    // stmt happens to be a WhileStatement and so we know it's going to\n    // establish its own LoopEntry when we explode it (below). Then this\n    // LabeledEntry would be unnecessary. Alternatively, we might be\n    // tempted not to pass stmt.label down into self.explodeStatement,\n    // because we've handled the label here, but that's a mistake because\n    // labeled loops may contain labeled continue statements, which is not\n    // something we can handle in this generic case. All in all, I think a\n    // little redundancy greatly simplifies the logic of this case, since\n    // it's clear that we handle all possible LabeledStatements correctly\n    // here, regardless of whether they interact with the leap manager\n    // themselves. Also remember that labels and break/continue-to-label\n    // statements are rare, and all of this logic happens at transform\n    // time, so it has no additional runtime cost.\n    self.leapManager.withEntry(\n      new leap.LabeledEntry(after, stmt.label),\n      function() {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      }\n    );\n\n    self.mark(after);\n\n    break;\n\n  case \"WhileStatement\":\n    var before = loc();\n    var after = loc();\n\n    self.mark(before);\n    self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, before, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n    self.jump(before);\n    self.mark(after);\n\n    break;\n\n  case \"DoWhileStatement\":\n    var first = loc();\n    var test = loc();\n    var after = loc();\n\n    self.mark(first);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, test, labelId),\n      function() { self.explode(path.get(\"body\")); }\n    );\n    self.mark(test);\n    self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n    self.mark(after);\n\n    break;\n\n  case \"ForStatement\":\n    var head = loc();\n    var update = loc();\n    var after = loc();\n\n    if (stmt.init) {\n      // We pass true here to indicate that if stmt.init is an expression\n      // then we do not care about its result.\n      self.explode(path.get(\"init\"), true);\n    }\n\n    self.mark(head);\n\n    if (stmt.test) {\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    } else {\n      // No test means continue unconditionally.\n    }\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, update, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.mark(update);\n\n    if (stmt.update) {\n      // We pass true here to indicate that if stmt.update is an\n      // expression then we do not care about its result.\n      self.explode(path.get(\"update\"), true);\n    }\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"ForInStatement\":\n    var head = loc();\n    var after = loc();\n\n    var keyIterNextFn = self.makeTempVar();\n    self.emitAssign(\n      keyIterNextFn,\n      b.callExpression(\n        runtimeProperty(\"keys\"),\n        [self.explodeExpression(path.get(\"right\"))]\n      )\n    );\n\n    self.mark(head);\n\n    var keyInfoTmpVar = self.makeTempVar();\n    self.jumpIf(\n      b.memberExpression(\n        b.assignmentExpression(\n          \"=\",\n          keyInfoTmpVar,\n          b.callExpression(keyIterNextFn, [])\n        ),\n        b.identifier(\"done\"),\n        false\n      ),\n      after\n    );\n\n    self.emitAssign(\n      stmt.left,\n      b.memberExpression(\n        keyInfoTmpVar,\n        b.identifier(\"value\"),\n        false\n      )\n    );\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, head, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"BreakStatement\":\n    self.emitAbruptCompletion({\n      type: \"break\",\n      target: self.leapManager.getBreakLoc(stmt.label)\n    });\n\n    break;\n\n  case \"ContinueStatement\":\n    self.emitAbruptCompletion({\n      type: \"continue\",\n      target: self.leapManager.getContinueLoc(stmt.label)\n    });\n\n    break;\n\n  case \"SwitchStatement\":\n    // Always save the discriminant into a temporary variable in case the\n    // test expressions overwrite values like context.sent.\n    var disc = self.emitAssign(\n      self.makeTempVar(),\n      self.explodeExpression(path.get(\"discriminant\"))\n    );\n\n    var after = loc();\n    var defaultLoc = loc();\n    var condition = defaultLoc;\n    var caseLocs = [];\n\n    // If there are no cases, .cases might be undefined.\n    var cases = stmt.cases || [];\n\n    for (var i = cases.length - 1; i >= 0; --i) {\n      var c = cases[i];\n      n.SwitchCase.assert(c);\n\n      if (c.test) {\n        condition = b.conditionalExpression(\n          b.binaryExpression(\"===\", disc, c.test),\n          caseLocs[i] = loc(),\n          condition\n        );\n      } else {\n        caseLocs[i] = defaultLoc;\n      }\n    }\n\n    self.jump(self.explodeExpression(\n      new types.NodePath(condition, path, \"discriminant\")\n    ));\n\n    self.leapManager.withEntry(\n      new leap.SwitchEntry(after),\n      function() {\n        path.get(\"cases\").each(function(casePath) {\n          var c = casePath.value;\n          var i = casePath.name;\n\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").each(\n            self.explodeStatement,\n            self\n          );\n        });\n      }\n    );\n\n    self.mark(after);\n    if (defaultLoc.value === -1) {\n      self.mark(defaultLoc);\n      assert.strictEqual(after.value, defaultLoc.value);\n    }\n\n    break;\n\n  case \"IfStatement\":\n    var elseLoc = stmt.alternate && loc();\n    var after = loc();\n\n    self.jumpIfNot(\n      self.explodeExpression(path.get(\"test\")),\n      elseLoc || after\n    );\n\n    self.explodeStatement(path.get(\"consequent\"));\n\n    if (elseLoc) {\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeStatement(path.get(\"alternate\"));\n    }\n\n    self.mark(after);\n\n    break;\n\n  case \"ReturnStatement\":\n    self.emitAbruptCompletion({\n      type: \"return\",\n      value: self.explodeExpression(path.get(\"argument\"))\n    });\n\n    break;\n\n  case \"WithStatement\":\n    throw new Error(\n      node.type + \" not supported in generator functions.\");\n\n  case \"TryStatement\":\n    var after = loc();\n\n    var handler = stmt.handler;\n    if (!handler && stmt.handlers) {\n      handler = stmt.handlers[0] || null;\n    }\n\n    var catchLoc = handler && loc();\n    var catchEntry = catchLoc && new leap.CatchEntry(\n      catchLoc,\n      handler.param\n    );\n\n    var finallyLoc = stmt.finalizer && loc();\n    var finallyEntry = finallyLoc &&\n      new leap.FinallyEntry(finallyLoc, after);\n\n    var tryEntry = new leap.TryEntry(\n      self.getUnmarkedCurrentLoc(),\n      catchEntry,\n      finallyEntry\n    );\n\n    self.tryEntries.push(tryEntry);\n    self.updateContextPrevLoc(tryEntry.firstLoc);\n\n    self.leapManager.withEntry(tryEntry, function() {\n      self.explodeStatement(path.get(\"block\"));\n\n      if (catchLoc) {\n        if (finallyLoc) {\n          // If we have both a catch block and a finally block, then\n          // because we emit the catch block first, we need to jump over\n          // it to the finally block.\n          self.jump(finallyLoc);\n\n        } else {\n          // If there is no finally block, then we need to jump over the\n          // catch block to the fall-through location.\n          self.jump(after);\n        }\n\n        self.updateContextPrevLoc(self.mark(catchLoc));\n\n        var bodyPath = path.get(\"handler\", \"body\");\n        var safeParam = self.makeTempVar();\n        self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n        var catchScope = bodyPath.scope;\n        var catchParamName = handler.param.name;\n        n.CatchClause.assert(catchScope.node);\n        assert.strictEqual(catchScope.lookup(catchParamName), catchScope);\n\n        types.visit(bodyPath, {\n          visitIdentifier: function(path) {\n            if (util.isReference(path, catchParamName) &&\n                path.scope.lookup(catchParamName) === catchScope) {\n              return safeParam;\n            }\n\n            this.traverse(path);\n          },\n\n          visitFunction: function(path) {\n            if (path.scope.declares(catchParamName)) {\n              // Don't descend into nested scopes that shadow the catch\n              // parameter with their own declarations. This isn't\n              // logically necessary because of the path.scope.lookup we\n              // do in visitIdentifier, but it saves time.\n              return false;\n            }\n\n            this.traverse(path);\n          }\n        });\n\n        self.leapManager.withEntry(catchEntry, function() {\n          self.explodeStatement(bodyPath);\n        });\n      }\n\n      if (finallyLoc) {\n        self.updateContextPrevLoc(self.mark(finallyLoc));\n\n        self.leapManager.withEntry(finallyEntry, function() {\n          self.explodeStatement(path.get(\"finalizer\"));\n        });\n\n        self.emit(b.returnStatement(b.callExpression(\n          self.contextProperty(\"finish\"),\n          [finallyEntry.firstLoc]\n        )));\n      }\n    });\n\n    self.mark(after);\n\n    break;\n\n  case \"ThrowStatement\":\n    self.emit(b.throwStatement(\n      self.explodeExpression(path.get(\"argument\"))\n    ));\n\n    break;\n\n  default:\n    throw new Error(\n      \"unknown Statement of type \" +\n        JSON.stringify(stmt.type));\n  }\n};\n\nEp.emitAbruptCompletion = function(record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(\n      false,\n      \"invalid completion record: \" +\n        JSON.stringify(record)\n    );\n  }\n\n  assert.notStrictEqual(\n    record.type, \"normal\",\n    \"normal completions are not abrupt\"\n  );\n\n  var abruptArgs = [b.literal(record.type)];\n\n  if (record.type === \"break\" ||\n      record.type === \"continue\") {\n    n.Literal.assert(record.target);\n    abruptArgs[1] = record.target;\n  } else if (record.type === \"return\" ||\n             record.type === \"throw\") {\n    if (record.value) {\n      n.Expression.assert(record.value);\n      abruptArgs[1] = record.value;\n    }\n  }\n\n  this.emit(\n    b.returnStatement(\n      b.callExpression(\n        this.contextProperty(\"abrupt\"),\n        abruptArgs\n      )\n    )\n  );\n};\n\nfunction isValidCompletion(record) {\n  var type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" ||\n      type === \"continue\") {\n    return !hasOwn.call(record, \"value\")\n        && n.Literal.check(record.target);\n  }\n\n  if (type === \"return\" ||\n      type === \"throw\") {\n    return hasOwn.call(record, \"value\")\n        && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function() {\n  return b.literal(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function(loc) {\n  if (loc) {\n    n.Literal.assert(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function(path, ignoreResult) {\n  assert.ok(path instanceof types.NodePath);\n\n  var expr = path.value;\n  if (expr) {\n    n.Expression.assert(expr);\n  } else {\n    return expr;\n  }\n\n  var self = this;\n  var result; // Used optionally by several cases below.\n\n  function finish(expr) {\n    n.Expression.assert(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(childPath instanceof types.NodePath);\n\n    assert.ok(\n      !ignoreChildResult || !tempVar,\n      \"Ignoring the result of a child expression but forcing it to \" +\n        \"be assigned to a temporary variable?\"\n    );\n\n    var result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || (hasLeapingChildren &&\n                           !n.Literal.check(result))) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(\n        tempVar || self.makeTempVar(),\n        result\n      );\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n  case \"MemberExpression\":\n    return finish(b.memberExpression(\n      self.explodeExpression(path.get(\"object\")),\n      expr.computed\n        ? explodeViaTempVar(null, path.get(\"property\"))\n        : expr.property,\n      expr.computed\n    ));\n\n  case \"CallExpression\":\n    var calleePath = path.get(\"callee\");\n    var argsPath = path.get(\"arguments\");\n\n    var newCallee;\n    var newArgs = [];\n\n    var hasLeapingArgs = false;\n    argsPath.each(function(argPath) {\n      hasLeapingArgs = hasLeapingArgs ||\n        meta.containsLeap(argPath.value);\n    });\n\n    if (n.MemberExpression.check(calleePath.value)) {\n      if (hasLeapingArgs) {\n        // If the arguments of the CallExpression contained any yield\n        // expressions, then we need to be sure to evaluate the callee\n        // before evaluating the arguments, but if the callee was a member\n        // expression, then we must be careful that the object of the\n        // member expression still gets bound to `this` for the call.\n\n        var newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(),\n          calleePath.get(\"object\")\n        );\n\n        var newProperty = calleePath.value.computed\n          ? explodeViaTempVar(null, calleePath.get(\"property\"))\n          : calleePath.value.property;\n\n        newArgs.unshift(newObject);\n\n        newCallee = b.memberExpression(\n          b.memberExpression(\n            newObject,\n            newProperty,\n            calleePath.value.computed\n          ),\n          b.identifier(\"call\"),\n          false\n        );\n\n      } else {\n        newCallee = self.explodeExpression(calleePath);\n      }\n\n    } else {\n      newCallee = self.explodeExpression(calleePath);\n\n      if (n.MemberExpression.check(newCallee)) {\n        // If the callee was not previously a MemberExpression, then the\n        // CallExpression was \"unqualified,\" meaning its `this` object\n        // should be the global object. If the exploded expression has\n        // become a MemberExpression (e.g. a context property, probably a\n        // temporary variable), then we need to force it to be unqualified\n        // by using the (0, object.property)(...) trick; otherwise, it\n        // will receive the object of the MemberExpression as its `this`\n        // object.\n        newCallee = b.sequenceExpression([\n          b.literal(0),\n          newCallee\n        ]);\n      }\n    }\n\n    argsPath.each(function(argPath) {\n      newArgs.push(explodeViaTempVar(null, argPath));\n    });\n\n    return finish(b.callExpression(\n      newCallee,\n      newArgs\n    ));\n\n  case \"NewExpression\":\n    return finish(b.newExpression(\n      explodeViaTempVar(null, path.get(\"callee\")),\n      path.get(\"arguments\").map(function(argPath) {\n        return explodeViaTempVar(null, argPath);\n      })\n    ));\n\n  case \"ObjectExpression\":\n    return finish(b.objectExpression(\n      path.get(\"properties\").map(function(propPath) {\n        return b.property(\n          propPath.value.kind,\n          propPath.value.key,\n          explodeViaTempVar(null, propPath.get(\"value\"))\n        );\n      })\n    ));\n\n  case \"ArrayExpression\":\n    return finish(b.arrayExpression(\n      path.get(\"elements\").map(function(elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })\n    ));\n\n  case \"SequenceExpression\":\n    var lastIndex = expr.expressions.length - 1;\n\n    path.get(\"expressions\").each(function(exprPath) {\n      if (exprPath.name === lastIndex) {\n        result = self.explodeExpression(exprPath, ignoreResult);\n      } else {\n        self.explodeExpression(exprPath, true);\n      }\n    });\n\n    return result;\n\n  case \"LogicalExpression\":\n    var after = loc();\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    var left = explodeViaTempVar(result, path.get(\"left\"));\n\n    if (expr.operator === \"&&\") {\n      self.jumpIfNot(left, after);\n    } else {\n      assert.strictEqual(expr.operator, \"||\");\n      self.jumpIf(left, after);\n    }\n\n    explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"ConditionalExpression\":\n    var elseLoc = loc();\n    var after = loc();\n    var test = self.explodeExpression(path.get(\"test\"));\n\n    self.jumpIfNot(test, elseLoc);\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n    self.jump(after);\n\n    self.mark(elseLoc);\n    explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"UnaryExpression\":\n    return finish(b.unaryExpression(\n      expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")),\n      !!expr.prefix\n    ));\n\n  case \"BinaryExpression\":\n    return finish(b.binaryExpression(\n      expr.operator,\n      explodeViaTempVar(null, path.get(\"left\")),\n      explodeViaTempVar(null, path.get(\"right\"))\n    ));\n\n  case \"AssignmentExpression\":\n    return finish(b.assignmentExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"left\")),\n      self.explodeExpression(path.get(\"right\"))\n    ));\n\n  case \"UpdateExpression\":\n    return finish(b.updateExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"argument\")),\n      expr.prefix\n    ));\n\n  case \"YieldExpression\":\n    var after = loc();\n    var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n    if (arg && expr.delegate) {\n      var result = self.makeTempVar();\n\n      self.emit(b.returnStatement(b.callExpression(\n        self.contextProperty(\"delegateYield\"), [\n          arg,\n          b.literal(result.property.name),\n          after\n        ]\n      )));\n\n      self.mark(after);\n\n      return result;\n    }\n\n    self.emitAssign(self.contextProperty(\"next\"), after);\n    self.emit(b.returnStatement(arg || null));\n    self.mark(after);\n\n    return self.contextProperty(\"sent\");\n\n  default:\n    throw new Error(\n      \"unknown Expression of type \" +\n        JSON.stringify(expr.type));\n  }\n};\n"]}