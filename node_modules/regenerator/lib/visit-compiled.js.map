{"version":3,"sources":["visit.js"],"names":[],"mappings":"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","file":"visit-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nvar assert = require(\"assert\");\nvar fs = require(\"fs\");\nvar recast = require(\"recast\");\nvar types = recast.types;\nvar n = types.namedTypes;\nvar b = types.builders;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar NodePath = types.NodePath;\nvar hoist = require(\"./hoist\").hoist;\nvar Emitter = require(\"./emit\").Emitter;\nvar util = require(\"./util\");\nvar runtimeProperty = util.runtimeProperty;\nvar getMarkInfo = require(\"private\").makeAccessor();\n\nexports.transform = function transform(node, options) {\n  options = options || {};\n\n  var path = node instanceof NodePath ? node : new NodePath(node);\n  visitor.visit(path, options);\n  node = path.value;\n\n  if (options.includeRuntime === true ||\n      (options.includeRuntime === 'if used' && visitor.wasChangeReported())) {\n    injectRuntime(n.File.check(node) ? node.program : node);\n  }\n\n  options.madeChanges = visitor.wasChangeReported();\n\n  return node;\n};\n\nfunction injectRuntime(program) {\n  n.Program.assert(program);\n\n  // Include the runtime by modifying the AST rather than by concatenating\n  // strings. This technique will allow for more accurate source mapping.\n  var runtimePath = require(\"..\").runtime.path;\n  var runtime = fs.readFileSync(runtimePath, \"utf8\");\n  var runtimeBody = recast.parse(runtime, {\n    sourceFileName: runtimePath\n  }).program.body;\n\n  var body = program.body;\n  body.unshift.apply(body, runtimeBody);\n}\n\nvar visitor = types.PathVisitor.fromMethodsObject({\n  reset: function(node, options) {\n    this.options = options;\n  },\n\n  visitFunction: function(path) {\n    // Calling this.traverse(path) first makes for a post-order traversal.\n    this.traverse(path);\n\n    var node = path.value;\n    var shouldTransformAsync = node.async && !this.options.disableAsync;\n\n    if (!node.generator && !shouldTransformAsync) {\n      return;\n    }\n\n    this.reportChanged();\n\n    if (node.expression) {\n      // Transform expression lambdas into normal functions.\n      node.expression = false;\n      node.body = b.blockStatement([\n        b.returnStatement(node.body)\n      ]);\n    }\n\n    if (shouldTransformAsync) {\n      awaitVisitor.visit(path.get(\"body\"));\n    }\n\n    var outerBody = [];\n    var innerBody = [];\n    var bodyPath = path.get(\"body\", \"body\");\n\n    bodyPath.each(function(childPath) {\n      var node = childPath.value;\n      if (node && node._blockHoist != null) {\n        outerBody.push(node);\n      } else {\n        innerBody.push(node);\n      }\n    });\n\n    if (outerBody.length > 0) {\n      // Only replace the inner body if we actually hoisted any statements\n      // to the outer body.\n      bodyPath.replace(innerBody);\n    }\n\n    var outerFnExpr = getOuterFnExpr(path);\n    // Note that getOuterFnExpr has the side-effect of ensuring that the\n    // function has a name (so node.id will always be an Identifier), even\n    // if a temporary name has to be synthesized.\n    n.Identifier.assert(node.id);\n    var innerFnId = b.identifier(node.id.name + \"$\");\n    var contextId = path.scope.declareTemporary(\"context$\");\n    var argsId = path.scope.declareTemporary(\"args$\");\n\n    // Turn all declarations into vars, and replace the original\n    // declarations with equivalent assignment expressions.\n    var vars = hoist(path);\n\n    var didRenameArguments = renameArguments(path, argsId);\n    if (didRenameArguments) {\n      vars = vars || b.variableDeclaration(\"var\", []);\n      vars.declarations.push(b.variableDeclarator(\n        argsId, b.identifier(\"arguments\")\n      ));\n    }\n\n    var emitter = new Emitter(contextId);\n    emitter.explode(path.get(\"body\"));\n\n    if (vars && vars.declarations.length > 0) {\n      outerBody.push(vars);\n    }\n\n    var wrapArgs = [\n      emitter.getContextFunction(innerFnId),\n      // Async functions that are not generators don't care about the\n      // outer function because they don't need it to be marked and don't\n      // inherit from its .prototype.\n      node.generator ? outerFnExpr : b.literal(null),\n      b.thisExpression()\n    ];\n\n    var tryLocsList = emitter.getTryLocsList();\n    if (tryLocsList) {\n      wrapArgs.push(tryLocsList);\n    }\n\n    var wrapCall = b.callExpression(\n      runtimeProperty(shouldTransformAsync ? \"async\" : \"wrap\"),\n      wrapArgs\n    );\n\n    outerBody.push(b.returnStatement(wrapCall));\n    node.body = b.blockStatement(outerBody);\n\n    var wasGeneratorFunction = node.generator;\n    if (wasGeneratorFunction) {\n      node.generator = false;\n    }\n\n    if (shouldTransformAsync) {\n      node.async = false;\n    }\n\n    if (wasGeneratorFunction &&\n        n.Expression.check(node)) {\n      return b.callExpression(runtimeProperty(\"mark\"), [node]);\n    }\n  },\n\n  visitForOfStatement: function(path) {\n    this.traverse(path);\n\n    var node = path.value;\n    var tempIterId = path.scope.declareTemporary(\"t$\");\n    var tempIterDecl = b.variableDeclarator(\n      tempIterId,\n      b.callExpression(\n        runtimeProperty(\"values\"),\n        [node.right]\n      )\n    );\n\n    var tempInfoId = path.scope.declareTemporary(\"t$\");\n    var tempInfoDecl = b.variableDeclarator(tempInfoId, null);\n\n    var init = node.left;\n    var loopId;\n    if (n.VariableDeclaration.check(init)) {\n      loopId = init.declarations[0].id;\n      init.declarations.push(tempIterDecl, tempInfoDecl);\n    } else {\n      loopId = init;\n      init = b.variableDeclaration(\"var\", [\n        tempIterDecl,\n        tempInfoDecl\n      ]);\n    }\n    n.Identifier.assert(loopId);\n\n    var loopIdAssignExprStmt = b.expressionStatement(\n      b.assignmentExpression(\n        \"=\",\n        loopId,\n        b.memberExpression(\n          tempInfoId,\n          b.identifier(\"value\"),\n          false\n        )\n      )\n    );\n\n    if (n.BlockStatement.check(node.body)) {\n      node.body.body.unshift(loopIdAssignExprStmt);\n    } else {\n      node.body = b.blockStatement([\n        loopIdAssignExprStmt,\n        node.body\n      ]);\n    }\n\n    return b.forStatement(\n      init,\n      b.unaryExpression(\n        \"!\",\n        b.memberExpression(\n          b.assignmentExpression(\n            \"=\",\n            tempInfoId,\n            b.callExpression(\n              b.memberExpression(\n                tempIterId,\n                b.identifier(\"next\"),\n                false\n              ),\n              []\n            )\n          ),\n          b.identifier(\"done\"),\n          false\n        )\n      ),\n      null,\n      node.body\n    );\n  }\n});\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  var node = funPath.value;\n  n.Function.assert(node);\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      n.FunctionDeclaration.check(node)) {\n    var pp = funPath.parent;\n\n    while (pp && !(n.BlockStatement.check(pp.value) ||\n                   n.Program.check(pp.value))) {\n      pp = pp.parent;\n    }\n\n    if (!pp) {\n      return node.id;\n    }\n\n    var markDecl = getRuntimeMarkDecl(pp);\n    var markedArray = markDecl.declarations[0].id;\n    var funDeclIdArray = markDecl.declarations[0].init.callee.object;\n    n.ArrayExpression.assert(funDeclIdArray);\n\n    var index = funDeclIdArray.elements.length;\n    funDeclIdArray.elements.push(node.id);\n\n    return b.memberExpression(\n      markedArray,\n      b.literal(index),\n      true\n    );\n  }\n\n  return node.id || (\n    node.id = funPath.scope.parent.declareTemporary(\"callee$\")\n  );\n}\n\nfunction getRuntimeMarkDecl(blockPath) {\n  assert.ok(blockPath instanceof NodePath);\n  var block = blockPath.node;\n  isArray.assert(block.body);\n\n  var info = getMarkInfo(block);\n  if (info.decl) {\n    return info.decl;\n  }\n\n  info.decl = b.variableDeclaration(\"var\", [\n    b.variableDeclarator(\n      blockPath.scope.declareTemporary(\"marked\"),\n      b.callExpression(\n        b.memberExpression(\n          b.arrayExpression([]),\n          b.identifier(\"map\"),\n          false\n        ),\n        [runtimeProperty(\"mark\")]\n      )\n    )\n  ]);\n\n  for (var i = 0; i < block.body.length; ++i) {\n    if (!shouldNotHoistAbove(blockPath.get(\"body\", i))) {\n      break;\n    }\n  }\n\n  blockPath.get(\"body\").insertAt(i, info.decl);\n\n  return info.decl;\n}\n\nfunction shouldNotHoistAbove(stmtPath) {\n  var value = stmtPath.value;\n  n.Statement.assert(value);\n\n  // If the first statement is a \"use strict\" declaration, make sure to\n  // insert hoisted declarations afterwards.\n  return n.ExpressionStatement.check(value) &&\n    n.Literal.check(value.expression) &&\n    value.expression.value === \"use strict\";\n}\n\nfunction renameArguments(funcPath, argsId) {\n  assert.ok(funcPath instanceof types.NodePath);\n  var func = funcPath.value;\n  var didRenameArguments = false;\n\n  recast.visit(funcPath, {\n    visitFunction: function(path) {\n      if (path.value === func) {\n        this.traverse(path);\n      } else {\n        return false;\n      }\n    },\n\n    visitIdentifier: function(path) {\n      if (path.value.name === \"arguments\" &&\n          util.isReference(path)) {\n        path.replace(argsId);\n        didRenameArguments = true;\n        return false;\n      }\n\n      this.traverse(path);\n    }\n  });\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return didRenameArguments;\n}\n\nvar awaitVisitor = types.PathVisitor.fromMethodsObject({\n  visitFunction: function(path) {\n    return false; // Don't descend into nested function scopes.\n  },\n\n  visitAwaitExpression: function(path) {\n    // Convert await and await* expressions to yield expressions.\n    var argument = path.value.argument;\n\n    // If the parser supports await* syntax using a boolean .all property\n    // (#171), desugar that syntax to yield Promise.all(argument).\n    if (path.value.all) {\n      argument = b.callExpression(\n        b.memberExpression(\n          b.identifier(\"Promise\"),\n          b.identifier(\"all\"),\n          false\n        ),\n        [argument]\n      );\n    }\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    return b.yieldExpression(\n      b.callExpression(\n        runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    );\n  }\n});\n"]}