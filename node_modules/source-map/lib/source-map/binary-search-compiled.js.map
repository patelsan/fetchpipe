{"version":3,"sources":["binary-search.js"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AAC9B,MAAI,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;CACrD;AACD,MAAM,CAAC,UAAU,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE;;AAEzC,SAAO,CAAC,oBAAoB,GAAG,CAAC,CAAC;AACjC,SAAO,CAAC,iBAAiB,GAAG,CAAC,CAAC;;;;;;;;;;;;;;;AAe9B,WAAS,eAAe;;;8BAAmD;UAAlD,IAAI;UAAE,KAAK;UAAE,OAAO;UAAE,SAAS;UAAE,QAAQ;UAAE,KAAK;AAUnE,SAAG,GACH,GAAG;;;;;;;;;;;;AADP,UAAI,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,IAAI,CAAA,GAAI,CAAC,CAAC,GAAG,IAAI,CAAC;AAChD,UAAI,GAAG,GAAG,QAAQ,CAAC,OAAO,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;AAClD,UAAI,GAAG,KAAK,CAAC,EAAE;;AAEb,eAAO,GAAG,CAAC;OACZ,MACI,IAAI,GAAG,GAAG,CAAC,EAAE;;AAEhB,YAAI,KAAK,GAAG,GAAG,GAAG,CAAC,EAAE;;eAEI,GAAG;gBAAE,KAAK;gBAAE,OAAO;gBAAE,SAAS;gBAAE,QAAQ;gBAAE,KAAK;;;SACvE;;;;AAID,YAAI,KAAK,IAAI,OAAO,CAAC,iBAAiB,EAAE;AACtC,iBAAO,KAAK,GAAG,SAAS,CAAC,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC,CAAC;SAC9C,MAAM;AACL,iBAAO,GAAG,CAAC;SACZ;OACF,MACI;;AAEH,YAAI,GAAG,GAAG,IAAI,GAAG,CAAC,EAAE;;eAEK,IAAI;gBAAE,GAAG;gBAAE,OAAO;gBAAE,SAAS;gBAAE,QAAQ;gBAAE,KAAK;;;SACtE;;;AAGD,YAAI,KAAK,IAAI,OAAO,CAAC,iBAAiB,EAAE;AACtC,iBAAO,GAAG,CAAC;SACZ,MAAM;AACL,iBAAO,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;SAC7B;OACF;KACF;GAAA;;;;;;;;;;;;;;;;;;;;AAoBD,SAAO,CAAC,MAAM,GAAG,SAAS,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE;AACpE,QAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;AAC1B,aAAO,CAAC,CAAC,CAAC;KACX;;AAED,QAAI,KAAK,GAAG,eAAe,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,EACxC,QAAQ,EAAE,KAAK,IAAI,OAAO,CAAC,oBAAoB,CAAC,CAAC;AAC7E,QAAI,KAAK,GAAG,CAAC,EAAE;AACb,aAAO,CAAC,CAAC,CAAC;KACX;;;;;AAKD,WAAO,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE;AACrB,UAAI,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE;AAChE,cAAM;OACP;AACD,QAAE,KAAK,CAAC;KACT;;AAED,WAAO,KAAK,CAAC;GACd,CAAC;CAEH,CAAC,CAAC","file":"binary-search-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  exports.GREATEST_LOWER_BOUND = 1;\n  exports.LEAST_UPPER_BOUND = 2;\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // Our needle is greater than aHaystack[mid].\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return aHigh < aHaystack.length ? aHigh : -1;\n      } else {\n        return mid;\n      }\n    }\n    else {\n      // Our needle is less than aHaystack[mid].\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return mid;\n      } else {\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of the closest element if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n      return -1;\n    }\n\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while (index - 1 >= 0) {\n      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n        break;\n      }\n      --index;\n    }\n\n    return index;\n  };\n\n});\n"]}