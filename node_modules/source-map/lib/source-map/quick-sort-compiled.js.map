{"version":3,"sources":["quick-sort.js"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;AAC9B,MAAI,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;CACrD;AACD,MAAM,CAAC,UAAU,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE;;;;;;;;;;;;;;;;;;;;;;AAsBzC,WAAS,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE;AACvB,QAAI,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAClB,OAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;AAChB,OAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;GACf;;;;;;;;;;AAUD,WAAS,gBAAgB,CAAC,GAAG,EAAE,IAAI,EAAE;AACnC,WAAO,IAAI,CAAC,KAAK,CAAC,GAAG,GAAI,IAAI,CAAC,MAAM,EAAE,IAAI,IAAI,GAAG,GAAG,CAAA,AAAC,AAAC,CAAC,CAAC;GACzD;;;;;;;;;;;;;;AAcD,WAAS,WAAW,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE;;;;;AAK1C,QAAI,CAAC,GAAG,CAAC,EAAE;;;;;;;;;;;;AAYT,UAAI,UAAU,GAAG,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,UAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;AAEd,UAAI,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC;AACzB,UAAI,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;;;;;;;;AAQnB,WAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;AAC1B,YAAI,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE;AAClC,WAAC,IAAI,CAAC,CAAC;AACP,cAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACjB;OACF;;AAED,UAAI,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;AACpB,UAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;;;AAId,iBAAW,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;AACvC,iBAAW,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;KACxC;GACF;;;;;;;;;;AAUD,SAAO,CAAC,SAAS,GAAG,UAAU,GAAG,EAAE,UAAU,EAAE;AAC7C,eAAW,CAAC,GAAG,EAAE,UAAU,EAAE,CAAC,EAAE,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;GACjD,CAAC;CAEH,CAAC,CAAC","file":"quick-sort-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  // It turns out that some (most?) JavaScript engines don't self-host\n  // `Array.prototype.sort`. This makes sense because C++ will likely remain\n  // faster than JS when doing raw CPU-intensive sorting. However, when using a\n  // custom comparator function, calling back and forth between the VM's C++ and\n  // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n  // worse generated code for the comparator function than would be optimal. In\n  // fact, when sorting with a comparator, these costs outweigh the benefits of\n  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n  // a ~3500ms mean speed-up in `bench/bench.html`.\n\n  /**\n   * Swap the elements indexed by `x` and `y` in the array `ary`.\n   *\n   * @param {Array} ary\n   *        The array.\n   * @param {Number} x\n   *        The index of the first item.\n   * @param {Number} y\n   *        The index of the second item.\n   */\n  function swap(ary, x, y) {\n    var temp = ary[x];\n    ary[x] = ary[y];\n    ary[y] = temp;\n  }\n\n  /**\n   * Returns a random integer within the range `low .. high` inclusive.\n   *\n   * @param {Number} low\n   *        The lower bound on the range.\n   * @param {Number} high\n   *        The upper bound on the range.\n   */\n  function randomIntInRange(low, high) {\n    return Math.round(low + (Math.random() * (high - low)));\n  }\n\n  /**\n   * The Quick Sort algorithm.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   * @param {Number} p\n   *        Start index of the array\n   * @param {Number} r\n   *        End index of the array\n   */\n  function doQuickSort(ary, comparator, p, r) {\n    // If our lower bound is less than our upper bound, we (1) partition the\n    // array into two pieces and (2) recurse on each half. If it is not, this is\n    // the empty array and our base case.\n\n    if (p < r) {\n      // (1) Partitioning.\n      //\n      // The partitioning chooses a pivot between `p` and `r` and moves all\n      // elements that are less than or equal to the pivot to the before it, and\n      // all the elements that are greater than it after it. The effect is that\n      // once partition is done, the pivot is in the exact place it will be when\n      // the array is put in sorted order, and it will not need to be moved\n      // again. This runs in O(n) time.\n\n      // Always choose a random pivot so that an input array which is reverse\n      // sorted does not cause O(n^2) running time.\n      var pivotIndex = randomIntInRange(p, r);\n      var i = p - 1;\n\n      swap(ary, pivotIndex, r);\n      var pivot = ary[r];\n\n      // Immediately after `j` is incremented in this loop, the following hold\n      // true:\n      //\n      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n      //\n      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n      for (var j = p; j < r; j++) {\n        if (comparator(ary[j], pivot) <= 0) {\n          i += 1;\n          swap(ary, i, j);\n        }\n      }\n\n      swap(ary, i + 1, j);\n      var q = i + 1;\n\n      // (2) Recurse on each half.\n\n      doQuickSort(ary, comparator, p, q - 1);\n      doQuickSort(ary, comparator, q + 1, r);\n    }\n  }\n\n  /**\n   * Sort the given array in-place with the given comparator function.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   */\n  exports.quickSort = function (ary, comparator) {\n    doQuickSort(ary, comparator, 0, ary.length - 1);\n  };\n\n});\n"]}